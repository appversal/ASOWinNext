/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stripe";
exports.ids = ["vendor-chunks/@stripe"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stripe/stripe-js/dist/pure.js":
/*!*****************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/dist/pure.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar RELEASE_TRAIN = 'v3';\n\nvar runtimeVersionToUrlVersion = function runtimeVersionToUrlVersion(version) {\n  return version === 3 ? 'v3' : version;\n};\n\nvar ORIGIN = 'https://js.stripe.com';\nvar STRIPE_JS_URL = \"\".concat(ORIGIN, \"/v3\") ;\nvar V3_URL_REGEX = /^https:\\/\\/js\\.stripe\\.com\\/v3\\/?(\\?.*)?$/;\nvar STRIPE_JS_URL_REGEX = /^https:\\/\\/js\\.stripe\\.com\\/(v3|[a-z]+)\\/stripe\\.js(\\?.*)?$/;\nvar EXISTING_SCRIPT_MESSAGE = 'loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used';\n\nvar isStripeJSURL = function isStripeJSURL(url) {\n  return V3_URL_REGEX.test(url) || STRIPE_JS_URL_REGEX.test(url);\n};\n\nvar findScript = function findScript() {\n  var scripts = document.querySelectorAll(\"script[src^=\\\"\".concat(ORIGIN, \"\\\"]\"));\n\n  for (var i = 0; i < scripts.length; i++) {\n    var script = scripts[i];\n\n    if (!isStripeJSURL(script.src)) {\n      continue;\n    }\n\n    return script;\n  }\n\n  return null;\n};\n\nvar injectScript = function injectScript(params) {\n  var queryString = params && !params.advancedFraudSignals ? '?advancedFraudSignals=false' : '';\n  var script = document.createElement('script');\n  script.src = \"\".concat(STRIPE_JS_URL).concat(queryString);\n  var headOrBody = document.head || document.body;\n\n  if (!headOrBody) {\n    throw new Error('Expected document.body not to be null. Stripe.js requires a <body> element.');\n  }\n\n  headOrBody.appendChild(script);\n  return script;\n};\n\nvar registerWrapper = function registerWrapper(stripe, startTime) {\n  if (!stripe || !stripe._registerWrapper) {\n    return;\n  }\n\n  stripe._registerWrapper({\n    name: 'stripe-js',\n    version: \"5.10.0\",\n    startTime: startTime\n  });\n};\n\nvar stripePromise = null;\nvar onErrorListener = null;\nvar onLoadListener = null;\n\nvar onError = function onError(reject) {\n  return function (cause) {\n    reject(new Error('Failed to load Stripe.js', {\n      cause: cause\n    }));\n  };\n};\n\nvar onLoad = function onLoad(resolve, reject) {\n  return function () {\n    if (window.Stripe) {\n      resolve(window.Stripe);\n    } else {\n      reject(new Error('Stripe.js not available'));\n    }\n  };\n};\n\nvar loadScript = function loadScript(params) {\n  // Ensure that we only attempt to load Stripe.js at most once\n  if (stripePromise !== null) {\n    return stripePromise;\n  }\n\n  stripePromise = new Promise(function (resolve, reject) {\n    if (typeof window === 'undefined' || typeof document === 'undefined') {\n      // Resolve to null when imported server side. This makes the module\n      // safe to import in an isomorphic code base.\n      resolve(null);\n      return;\n    }\n\n    if (window.Stripe && params) {\n      console.warn(EXISTING_SCRIPT_MESSAGE);\n    }\n\n    if (window.Stripe) {\n      resolve(window.Stripe);\n      return;\n    }\n\n    try {\n      var script = findScript();\n\n      if (script && params) {\n        console.warn(EXISTING_SCRIPT_MESSAGE);\n      } else if (!script) {\n        script = injectScript(params);\n      } else if (script && onLoadListener !== null && onErrorListener !== null) {\n        var _script$parentNode;\n\n        // remove event listeners\n        script.removeEventListener('load', onLoadListener);\n        script.removeEventListener('error', onErrorListener); // if script exists, but we are reloading due to an error,\n        // reload script to trigger 'load' event\n\n        (_script$parentNode = script.parentNode) === null || _script$parentNode === void 0 ? void 0 : _script$parentNode.removeChild(script);\n        script = injectScript(params);\n      }\n\n      onLoadListener = onLoad(resolve, reject);\n      onErrorListener = onError(reject);\n      script.addEventListener('load', onLoadListener);\n      script.addEventListener('error', onErrorListener);\n    } catch (error) {\n      reject(error);\n      return;\n    }\n  }); // Resets stripePromise on error\n\n  return stripePromise[\"catch\"](function (error) {\n    stripePromise = null;\n    return Promise.reject(error);\n  });\n};\nvar initStripe = function initStripe(maybeStripe, args, startTime) {\n  if (maybeStripe === null) {\n    return null;\n  }\n\n  var pk = args[0];\n  var isTestKey = pk.match(/^pk_test/); // @ts-expect-error this is not publicly typed\n\n  var version = runtimeVersionToUrlVersion(maybeStripe.version);\n  var expectedVersion = RELEASE_TRAIN;\n\n  if (isTestKey && version !== expectedVersion) {\n    console.warn(\"Stripe.js@\".concat(version, \" was loaded on the page, but @stripe/stripe-js@\").concat(\"5.10.0\", \" expected Stripe.js@\").concat(expectedVersion, \". This may result in unexpected behavior. For more information, see https://docs.stripe.com/sdks/stripejs-versioning\"));\n  }\n\n  var stripe = maybeStripe.apply(undefined, args);\n  registerWrapper(stripe, startTime);\n  return stripe;\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nvar validateLoadParams = function validateLoadParams(params) {\n  var errorMessage = \"invalid load parameters; expected object of shape\\n\\n    {advancedFraudSignals: boolean}\\n\\nbut received\\n\\n    \".concat(JSON.stringify(params), \"\\n\");\n\n  if (params === null || _typeof(params) !== 'object') {\n    throw new Error(errorMessage);\n  }\n\n  if (Object.keys(params).length === 1 && typeof params.advancedFraudSignals === 'boolean') {\n    return params;\n  }\n\n  throw new Error(errorMessage);\n};\n\nvar loadParams;\nvar loadStripeCalled = false;\nvar loadStripe = function loadStripe() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  loadStripeCalled = true;\n  var startTime = Date.now();\n  return loadScript(loadParams).then(function (maybeStripe) {\n    return initStripe(maybeStripe, args, startTime);\n  });\n};\n\nloadStripe.setLoadParameters = function (params) {\n  // we won't throw an error if setLoadParameters is called with the same values as before\n  if (loadStripeCalled && loadParams) {\n    var validatedParams = validateLoadParams(params);\n    var parameterKeys = Object.keys(validatedParams);\n    var sameParameters = parameterKeys.reduce(function (previousValue, currentValue) {\n      var _loadParams;\n\n      return previousValue && params[currentValue] === ((_loadParams = loadParams) === null || _loadParams === void 0 ? void 0 : _loadParams[currentValue]);\n    }, true);\n\n    if (sameParameters) {\n      return;\n    }\n  }\n\n  if (loadStripeCalled) {\n    throw new Error('You cannot change load parameters after calling loadStripe');\n  }\n\n  loadParams = validateLoadParams(params);\n};\n\nexports.loadStripe = loadStripe;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvZGlzdC9wdXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3STs7QUFFeEk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsK0NBQStDLGlDQUFpQyw4QkFBOEI7O0FBRTlHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsYUFBYTtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wcmF0aGFtZ3VwdGEvRGVza3RvcC9BcHBWZXJzYWwvQVNPV0lOL0FTT1dpbk5leHQvbm9kZV9tb2R1bGVzL0BzdHJpcGUvc3RyaXBlLWpzL2Rpc3QvcHVyZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbnZhciBSRUxFQVNFX1RSQUlOID0gJ3YzJztcblxudmFyIHJ1bnRpbWVWZXJzaW9uVG9VcmxWZXJzaW9uID0gZnVuY3Rpb24gcnVudGltZVZlcnNpb25Ub1VybFZlcnNpb24odmVyc2lvbikge1xuICByZXR1cm4gdmVyc2lvbiA9PT0gMyA/ICd2MycgOiB2ZXJzaW9uO1xufTtcblxudmFyIE9SSUdJTiA9ICdodHRwczovL2pzLnN0cmlwZS5jb20nO1xudmFyIFNUUklQRV9KU19VUkwgPSBcIlwiLmNvbmNhdChPUklHSU4sIFwiL3YzXCIpIDtcbnZhciBWM19VUkxfUkVHRVggPSAvXmh0dHBzOlxcL1xcL2pzXFwuc3RyaXBlXFwuY29tXFwvdjNcXC8/KFxcPy4qKT8kLztcbnZhciBTVFJJUEVfSlNfVVJMX1JFR0VYID0gL15odHRwczpcXC9cXC9qc1xcLnN0cmlwZVxcLmNvbVxcLyh2M3xbYS16XSspXFwvc3RyaXBlXFwuanMoXFw/LiopPyQvO1xudmFyIEVYSVNUSU5HX1NDUklQVF9NRVNTQUdFID0gJ2xvYWRTdHJpcGUuc2V0TG9hZFBhcmFtZXRlcnMgd2FzIGNhbGxlZCBidXQgYW4gZXhpc3RpbmcgU3RyaXBlLmpzIHNjcmlwdCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQ7IGV4aXN0aW5nIHNjcmlwdCBwYXJhbWV0ZXJzIHdpbGwgYmUgdXNlZCc7XG5cbnZhciBpc1N0cmlwZUpTVVJMID0gZnVuY3Rpb24gaXNTdHJpcGVKU1VSTCh1cmwpIHtcbiAgcmV0dXJuIFYzX1VSTF9SRUdFWC50ZXN0KHVybCkgfHwgU1RSSVBFX0pTX1VSTF9SRUdFWC50ZXN0KHVybCk7XG59O1xuXG52YXIgZmluZFNjcmlwdCA9IGZ1bmN0aW9uIGZpbmRTY3JpcHQoKSB7XG4gIHZhciBzY3JpcHRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInNjcmlwdFtzcmNePVxcXCJcIi5jb25jYXQoT1JJR0lOLCBcIlxcXCJdXCIpKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2NyaXB0ID0gc2NyaXB0c1tpXTtcblxuICAgIGlmICghaXNTdHJpcGVKU1VSTChzY3JpcHQuc3JjKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjcmlwdDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIGluamVjdFNjcmlwdCA9IGZ1bmN0aW9uIGluamVjdFNjcmlwdChwYXJhbXMpIHtcbiAgdmFyIHF1ZXJ5U3RyaW5nID0gcGFyYW1zICYmICFwYXJhbXMuYWR2YW5jZWRGcmF1ZFNpZ25hbHMgPyAnP2FkdmFuY2VkRnJhdWRTaWduYWxzPWZhbHNlJyA6ICcnO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC5zcmMgPSBcIlwiLmNvbmNhdChTVFJJUEVfSlNfVVJMKS5jb25jYXQocXVlcnlTdHJpbmcpO1xuICB2YXIgaGVhZE9yQm9keSA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keTtcblxuICBpZiAoIWhlYWRPckJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGRvY3VtZW50LmJvZHkgbm90IHRvIGJlIG51bGwuIFN0cmlwZS5qcyByZXF1aXJlcyBhIDxib2R5PiBlbGVtZW50LicpO1xuICB9XG5cbiAgaGVhZE9yQm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICByZXR1cm4gc2NyaXB0O1xufTtcblxudmFyIHJlZ2lzdGVyV3JhcHBlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyV3JhcHBlcihzdHJpcGUsIHN0YXJ0VGltZSkge1xuICBpZiAoIXN0cmlwZSB8fCAhc3RyaXBlLl9yZWdpc3RlcldyYXBwZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHJpcGUuX3JlZ2lzdGVyV3JhcHBlcih7XG4gICAgbmFtZTogJ3N0cmlwZS1qcycsXG4gICAgdmVyc2lvbjogXCI1LjEwLjBcIixcbiAgICBzdGFydFRpbWU6IHN0YXJ0VGltZVxuICB9KTtcbn07XG5cbnZhciBzdHJpcGVQcm9taXNlID0gbnVsbDtcbnZhciBvbkVycm9yTGlzdGVuZXIgPSBudWxsO1xudmFyIG9uTG9hZExpc3RlbmVyID0gbnVsbDtcblxudmFyIG9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKHJlamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNhdXNlKSB7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgU3RyaXBlLmpzJywge1xuICAgICAgY2F1c2U6IGNhdXNlXG4gICAgfSkpO1xuICB9O1xufTtcblxudmFyIG9uTG9hZCA9IGZ1bmN0aW9uIG9uTG9hZChyZXNvbHZlLCByZWplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod2luZG93LlN0cmlwZSkge1xuICAgICAgcmVzb2x2ZSh3aW5kb3cuU3RyaXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcignU3RyaXBlLmpzIG5vdCBhdmFpbGFibGUnKSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIGxvYWRTY3JpcHQgPSBmdW5jdGlvbiBsb2FkU2NyaXB0KHBhcmFtcykge1xuICAvLyBFbnN1cmUgdGhhdCB3ZSBvbmx5IGF0dGVtcHQgdG8gbG9hZCBTdHJpcGUuanMgYXQgbW9zdCBvbmNlXG4gIGlmIChzdHJpcGVQcm9taXNlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHN0cmlwZVByb21pc2U7XG4gIH1cblxuICBzdHJpcGVQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBSZXNvbHZlIHRvIG51bGwgd2hlbiBpbXBvcnRlZCBzZXJ2ZXIgc2lkZS4gVGhpcyBtYWtlcyB0aGUgbW9kdWxlXG4gICAgICAvLyBzYWZlIHRvIGltcG9ydCBpbiBhbiBpc29tb3JwaGljIGNvZGUgYmFzZS5cbiAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5TdHJpcGUgJiYgcGFyYW1zKSB7XG4gICAgICBjb25zb2xlLndhcm4oRVhJU1RJTkdfU0NSSVBUX01FU1NBR0UpO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuU3RyaXBlKSB7XG4gICAgICByZXNvbHZlKHdpbmRvdy5TdHJpcGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgc2NyaXB0ID0gZmluZFNjcmlwdCgpO1xuXG4gICAgICBpZiAoc2NyaXB0ICYmIHBhcmFtcykge1xuICAgICAgICBjb25zb2xlLndhcm4oRVhJU1RJTkdfU0NSSVBUX01FU1NBR0UpO1xuICAgICAgfSBlbHNlIGlmICghc2NyaXB0KSB7XG4gICAgICAgIHNjcmlwdCA9IGluamVjdFNjcmlwdChwYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmIChzY3JpcHQgJiYgb25Mb2FkTGlzdGVuZXIgIT09IG51bGwgJiYgb25FcnJvckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfc2NyaXB0JHBhcmVudE5vZGU7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICBzY3JpcHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZExpc3RlbmVyKTtcbiAgICAgICAgc2NyaXB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvckxpc3RlbmVyKTsgLy8gaWYgc2NyaXB0IGV4aXN0cywgYnV0IHdlIGFyZSByZWxvYWRpbmcgZHVlIHRvIGFuIGVycm9yLFxuICAgICAgICAvLyByZWxvYWQgc2NyaXB0IHRvIHRyaWdnZXIgJ2xvYWQnIGV2ZW50XG5cbiAgICAgICAgKF9zY3JpcHQkcGFyZW50Tm9kZSA9IHNjcmlwdC5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfc2NyaXB0JHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zY3JpcHQkcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICBzY3JpcHQgPSBpbmplY3RTY3JpcHQocGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgb25Mb2FkTGlzdGVuZXIgPSBvbkxvYWQocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIG9uRXJyb3JMaXN0ZW5lciA9IG9uRXJyb3IocmVqZWN0KTtcbiAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkTGlzdGVuZXIpO1xuICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvckxpc3RlbmVyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0pOyAvLyBSZXNldHMgc3RyaXBlUHJvbWlzZSBvbiBlcnJvclxuXG4gIHJldHVybiBzdHJpcGVQcm9taXNlW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgc3RyaXBlUHJvbWlzZSA9IG51bGw7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfSk7XG59O1xudmFyIGluaXRTdHJpcGUgPSBmdW5jdGlvbiBpbml0U3RyaXBlKG1heWJlU3RyaXBlLCBhcmdzLCBzdGFydFRpbWUpIHtcbiAgaWYgKG1heWJlU3RyaXBlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGsgPSBhcmdzWzBdO1xuICB2YXIgaXNUZXN0S2V5ID0gcGsubWF0Y2goL15wa190ZXN0Lyk7IC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBpcyBub3QgcHVibGljbHkgdHlwZWRcblxuICB2YXIgdmVyc2lvbiA9IHJ1bnRpbWVWZXJzaW9uVG9VcmxWZXJzaW9uKG1heWJlU3RyaXBlLnZlcnNpb24pO1xuICB2YXIgZXhwZWN0ZWRWZXJzaW9uID0gUkVMRUFTRV9UUkFJTjtcblxuICBpZiAoaXNUZXN0S2V5ICYmIHZlcnNpb24gIT09IGV4cGVjdGVkVmVyc2lvbikge1xuICAgIGNvbnNvbGUud2FybihcIlN0cmlwZS5qc0BcIi5jb25jYXQodmVyc2lvbiwgXCIgd2FzIGxvYWRlZCBvbiB0aGUgcGFnZSwgYnV0IEBzdHJpcGUvc3RyaXBlLWpzQFwiKS5jb25jYXQoXCI1LjEwLjBcIiwgXCIgZXhwZWN0ZWQgU3RyaXBlLmpzQFwiKS5jb25jYXQoZXhwZWN0ZWRWZXJzaW9uLCBcIi4gVGhpcyBtYXkgcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly9kb2NzLnN0cmlwZS5jb20vc2Rrcy9zdHJpcGVqcy12ZXJzaW9uaW5nXCIpKTtcbiAgfVxuXG4gIHZhciBzdHJpcGUgPSBtYXliZVN0cmlwZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICByZWdpc3RlcldyYXBwZXIoc3RyaXBlLCBzdGFydFRpbWUpO1xuICByZXR1cm4gc3RyaXBlO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcblxudmFyIHZhbGlkYXRlTG9hZFBhcmFtcyA9IGZ1bmN0aW9uIHZhbGlkYXRlTG9hZFBhcmFtcyhwYXJhbXMpIHtcbiAgdmFyIGVycm9yTWVzc2FnZSA9IFwiaW52YWxpZCBsb2FkIHBhcmFtZXRlcnM7IGV4cGVjdGVkIG9iamVjdCBvZiBzaGFwZVxcblxcbiAgICB7YWR2YW5jZWRGcmF1ZFNpZ25hbHM6IGJvb2xlYW59XFxuXFxuYnV0IHJlY2VpdmVkXFxuXFxuICAgIFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShwYXJhbXMpLCBcIlxcblwiKTtcblxuICBpZiAocGFyYW1zID09PSBudWxsIHx8IF90eXBlb2YocGFyYW1zKSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgcGFyYW1zLmFkdmFuY2VkRnJhdWRTaWduYWxzID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG59O1xuXG52YXIgbG9hZFBhcmFtcztcbnZhciBsb2FkU3RyaXBlQ2FsbGVkID0gZmFsc2U7XG52YXIgbG9hZFN0cmlwZSA9IGZ1bmN0aW9uIGxvYWRTdHJpcGUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBsb2FkU3RyaXBlQ2FsbGVkID0gdHJ1ZTtcbiAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIHJldHVybiBsb2FkU2NyaXB0KGxvYWRQYXJhbXMpLnRoZW4oZnVuY3Rpb24gKG1heWJlU3RyaXBlKSB7XG4gICAgcmV0dXJuIGluaXRTdHJpcGUobWF5YmVTdHJpcGUsIGFyZ3MsIHN0YXJ0VGltZSk7XG4gIH0pO1xufTtcblxubG9hZFN0cmlwZS5zZXRMb2FkUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgLy8gd2Ugd29uJ3QgdGhyb3cgYW4gZXJyb3IgaWYgc2V0TG9hZFBhcmFtZXRlcnMgaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIGJlZm9yZVxuICBpZiAobG9hZFN0cmlwZUNhbGxlZCAmJiBsb2FkUGFyYW1zKSB7XG4gICAgdmFyIHZhbGlkYXRlZFBhcmFtcyA9IHZhbGlkYXRlTG9hZFBhcmFtcyhwYXJhbXMpO1xuICAgIHZhciBwYXJhbWV0ZXJLZXlzID0gT2JqZWN0LmtleXModmFsaWRhdGVkUGFyYW1zKTtcbiAgICB2YXIgc2FtZVBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJLZXlzLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSB7XG4gICAgICB2YXIgX2xvYWRQYXJhbXM7XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlICYmIHBhcmFtc1tjdXJyZW50VmFsdWVdID09PSAoKF9sb2FkUGFyYW1zID0gbG9hZFBhcmFtcykgPT09IG51bGwgfHwgX2xvYWRQYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sb2FkUGFyYW1zW2N1cnJlbnRWYWx1ZV0pO1xuICAgIH0sIHRydWUpO1xuXG4gICAgaWYgKHNhbWVQYXJhbWV0ZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvYWRTdHJpcGVDYWxsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgY2hhbmdlIGxvYWQgcGFyYW1ldGVycyBhZnRlciBjYWxsaW5nIGxvYWRTdHJpcGUnKTtcbiAgfVxuXG4gIGxvYWRQYXJhbXMgPSB2YWxpZGF0ZUxvYWRQYXJhbXMocGFyYW1zKTtcbn07XG5cbmV4cG9ydHMubG9hZFN0cmlwZSA9IGxvYWRTdHJpcGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/dist/pure.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/stripe-js/pure/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/pure/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/pure */ \"(ssr)/./node_modules/@stripe/stripe-js/dist/pure.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvcHVyZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwrR0FBd0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wcmF0aGFtZ3VwdGEvRGVza3RvcC9BcHBWZXJzYWwvQVNPV0lOL0FTT1dpbk5leHQvbm9kZV9tb2R1bGVzL0BzdHJpcGUvc3RyaXBlLWpzL3B1cmUvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L3B1cmUnKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/pure/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressElement: () => (/* binding */ AddressElement),\n/* harmony export */   AffirmMessageElement: () => (/* binding */ AffirmMessageElement),\n/* harmony export */   AfterpayClearpayMessageElement: () => (/* binding */ AfterpayClearpayMessageElement),\n/* harmony export */   AuBankAccountElement: () => (/* binding */ AuBankAccountElement),\n/* harmony export */   CardCvcElement: () => (/* binding */ CardCvcElement),\n/* harmony export */   CardElement: () => (/* binding */ CardElement),\n/* harmony export */   CardExpiryElement: () => (/* binding */ CardExpiryElement),\n/* harmony export */   CardNumberElement: () => (/* binding */ CardNumberElement),\n/* harmony export */   CheckoutProvider: () => (/* binding */ CheckoutProvider),\n/* harmony export */   CurrencySelectorElement: () => (/* binding */ CurrencySelectorElement),\n/* harmony export */   Elements: () => (/* binding */ Elements),\n/* harmony export */   ElementsConsumer: () => (/* binding */ ElementsConsumer),\n/* harmony export */   EmbeddedCheckout: () => (/* binding */ EmbeddedCheckout),\n/* harmony export */   EmbeddedCheckoutProvider: () => (/* binding */ EmbeddedCheckoutProvider),\n/* harmony export */   EpsBankElement: () => (/* binding */ EpsBankElement),\n/* harmony export */   ExpressCheckoutElement: () => (/* binding */ ExpressCheckoutElement),\n/* harmony export */   FpxBankElement: () => (/* binding */ FpxBankElement),\n/* harmony export */   IbanElement: () => (/* binding */ IbanElement),\n/* harmony export */   IdealBankElement: () => (/* binding */ IdealBankElement),\n/* harmony export */   LinkAuthenticationElement: () => (/* binding */ LinkAuthenticationElement),\n/* harmony export */   P24BankElement: () => (/* binding */ P24BankElement),\n/* harmony export */   PaymentElement: () => (/* binding */ PaymentElement),\n/* harmony export */   PaymentMethodMessagingElement: () => (/* binding */ PaymentMethodMessagingElement),\n/* harmony export */   PaymentRequestButtonElement: () => (/* binding */ PaymentRequestButtonElement),\n/* harmony export */   ShippingAddressElement: () => (/* binding */ ShippingAddressElement),\n/* harmony export */   TaxIdElement: () => (/* binding */ TaxIdElement),\n/* harmony export */   useCheckout: () => (/* binding */ useCheckout),\n/* harmony export */   useElements: () => (/* binding */ useElements),\n/* harmony export */   useStripe: () => (/* binding */ useStripe)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n\n\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar useAttachEvent = function useAttachEvent(element, event, cb) {\n  var cbDefined = !!cb;\n  var cbRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(cb); // In many integrations the callback prop changes on each render.\n  // Using a ref saves us from calling element.on/.off every render.\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    cbRef.current = cb;\n  }, [cb]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (!cbDefined || !element) {\n      return function () {};\n    }\n\n    var decoratedCb = function decoratedCb() {\n      if (cbRef.current) {\n        cbRef.current.apply(cbRef, arguments);\n      }\n    };\n\n    element.on(event, decoratedCb);\n    return function () {\n      element.off(event, decoratedCb);\n    };\n  }, [cbDefined, event, element, cbRef]);\n};\n\nvar usePrevious = function usePrevious(value) {\n  var ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(value);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n};\n\nvar isUnknownObject = function isUnknownObject(raw) {\n  return raw !== null && _typeof(raw) === 'object';\n};\nvar isPromise = function isPromise(raw) {\n  return isUnknownObject(raw) && typeof raw.then === 'function';\n}; // We are using types to enforce the `stripe` prop in this lib,\n// but in an untyped integration `stripe` could be anything, so we need\n// to do some sanity validation to prevent type errors.\n\nvar isStripe = function isStripe(raw) {\n  return isUnknownObject(raw) && typeof raw.elements === 'function' && typeof raw.createToken === 'function' && typeof raw.createPaymentMethod === 'function' && typeof raw.confirmCardPayment === 'function';\n};\n\nvar PLAIN_OBJECT_STR = '[object Object]';\nvar isEqual = function isEqual(left, right) {\n  if (!isUnknownObject(left) || !isUnknownObject(right)) {\n    return left === right;\n  }\n\n  var leftArray = Array.isArray(left);\n  var rightArray = Array.isArray(right);\n  if (leftArray !== rightArray) return false;\n  var leftPlainObject = Object.prototype.toString.call(left) === PLAIN_OBJECT_STR;\n  var rightPlainObject = Object.prototype.toString.call(right) === PLAIN_OBJECT_STR;\n  if (leftPlainObject !== rightPlainObject) return false; // not sure what sort of special object this is (regexp is one option), so\n  // fallback to reference check.\n\n  if (!leftPlainObject && !leftArray) return left === right;\n  var leftKeys = Object.keys(left);\n  var rightKeys = Object.keys(right);\n  if (leftKeys.length !== rightKeys.length) return false;\n  var keySet = {};\n\n  for (var i = 0; i < leftKeys.length; i += 1) {\n    keySet[leftKeys[i]] = true;\n  }\n\n  for (var _i = 0; _i < rightKeys.length; _i += 1) {\n    keySet[rightKeys[_i]] = true;\n  }\n\n  var allKeys = Object.keys(keySet);\n\n  if (allKeys.length !== leftKeys.length) {\n    return false;\n  }\n\n  var l = left;\n  var r = right;\n\n  var pred = function pred(key) {\n    return isEqual(l[key], r[key]);\n  };\n\n  return allKeys.every(pred);\n};\n\nvar extractAllowedOptionsUpdates = function extractAllowedOptionsUpdates(options, prevOptions, immutableKeys) {\n  if (!isUnknownObject(options)) {\n    return null;\n  }\n\n  return Object.keys(options).reduce(function (newOptions, key) {\n    var isUpdated = !isUnknownObject(prevOptions) || !isEqual(options[key], prevOptions[key]);\n\n    if (immutableKeys.includes(key)) {\n      if (isUpdated) {\n        console.warn(\"Unsupported prop change: options.\".concat(key, \" is not a mutable property.\"));\n      }\n\n      return newOptions;\n    }\n\n    if (!isUpdated) {\n      return newOptions;\n    }\n\n    return _objectSpread2(_objectSpread2({}, newOptions || {}), {}, _defineProperty({}, key, options[key]));\n  }, null);\n};\n\nvar INVALID_STRIPE_ERROR$2 = 'Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.'; // We are using types to enforce the `stripe` prop in this lib, but in a real\n// integration `stripe` could be anything, so we need to do some sanity\n// validation to prevent type errors.\n\nvar validateStripe = function validateStripe(maybeStripe) {\n  var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR$2;\n\n  if (maybeStripe === null || isStripe(maybeStripe)) {\n    return maybeStripe;\n  }\n\n  throw new Error(errorMsg);\n};\n\nvar parseStripeProp = function parseStripeProp(raw) {\n  var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR$2;\n\n  if (isPromise(raw)) {\n    return {\n      tag: 'async',\n      stripePromise: Promise.resolve(raw).then(function (result) {\n        return validateStripe(result, errorMsg);\n      })\n    };\n  }\n\n  var stripe = validateStripe(raw, errorMsg);\n\n  if (stripe === null) {\n    return {\n      tag: 'empty'\n    };\n  }\n\n  return {\n    tag: 'sync',\n    stripe: stripe\n  };\n};\n\nvar registerWithStripeJs = function registerWithStripeJs(stripe) {\n  if (!stripe || !stripe._registerWrapper || !stripe.registerAppInfo) {\n    return;\n  }\n\n  stripe._registerWrapper({\n    name: 'react-stripe-js',\n    version: \"3.10.0\"\n  });\n\n  stripe.registerAppInfo({\n    name: 'react-stripe-js',\n    version: \"3.10.0\",\n    url: 'https://stripe.com/docs/stripe-js/react'\n  });\n};\n\nvar ElementsContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nElementsContext.displayName = 'ElementsContext';\nvar parseElementsContext = function parseElementsContext(ctx, useCase) {\n  if (!ctx) {\n    throw new Error(\"Could not find Elements context; You need to wrap the part of your app that \".concat(useCase, \" in an <Elements> provider.\"));\n  }\n\n  return ctx;\n};\n/**\n * The `Elements` provider allows you to use [Element components](https://stripe.com/docs/stripe-js/react#element-components) and access the [Stripe object](https://stripe.com/docs/js/initializing) in any nested component.\n * Render an `Elements` provider at the root of your React app so that it is available everywhere you need it.\n *\n * To use the `Elements` provider, call `loadStripe` from `@stripe/stripe-js` with your publishable key.\n * The `loadStripe` function will asynchronously load the Stripe.js script and initialize a `Stripe` object.\n * Pass the returned `Promise` to `Elements`.\n *\n * @docs https://docs.stripe.com/sdks/stripejs-react?ui=elements#elements-provider\n */\n\nvar Elements = function Elements(_ref) {\n  var rawStripeProp = _ref.stripe,\n      options = _ref.options,\n      children = _ref.children;\n  var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return parseStripeProp(rawStripeProp);\n  }, [rawStripeProp]); // For a sync stripe instance, initialize into context\n\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(function () {\n    return {\n      stripe: parsed.tag === 'sync' ? parsed.stripe : null,\n      elements: parsed.tag === 'sync' ? parsed.stripe.elements(options) : null\n    };\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      ctx = _React$useState2[0],\n      setContext = _React$useState2[1];\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    var isMounted = true;\n\n    var safeSetContext = function safeSetContext(stripe) {\n      setContext(function (ctx) {\n        // no-op if we already have a stripe instance (https://github.com/stripe/react-stripe-js/issues/296)\n        if (ctx.stripe) return ctx;\n        return {\n          stripe: stripe,\n          elements: stripe.elements(options)\n        };\n      });\n    }; // For an async stripePromise, store it in context once resolved\n\n\n    if (parsed.tag === 'async' && !ctx.stripe) {\n      parsed.stripePromise.then(function (stripe) {\n        if (stripe && isMounted) {\n          // Only update Elements context if the component is still mounted\n          // and stripe is not null. We allow stripe to be null to make\n          // handling SSR easier.\n          safeSetContext(stripe);\n        }\n      });\n    } else if (parsed.tag === 'sync' && !ctx.stripe) {\n      // Or, handle a sync stripe instance going from null -> populated\n      safeSetContext(parsed.stripe);\n    }\n\n    return function () {\n      isMounted = false;\n    };\n  }, [parsed, ctx, options]); // Warn on changes to stripe prop\n\n  var prevStripe = usePrevious(rawStripeProp);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (prevStripe !== null && prevStripe !== rawStripeProp) {\n      console.warn('Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.');\n    }\n  }, [prevStripe, rawStripeProp]); // Apply updates to elements when options prop has relevant changes\n\n  var prevOptions = usePrevious(options);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (!ctx.elements) {\n      return;\n    }\n\n    var updates = extractAllowedOptionsUpdates(options, prevOptions, ['clientSecret', 'fonts']);\n\n    if (updates) {\n      ctx.elements.update(updates);\n    }\n  }, [options, prevOptions, ctx.elements]); // Attach react-stripe-js version to stripe.js instance\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    registerWithStripeJs(ctx.stripe);\n  }, [ctx.stripe]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ElementsContext.Provider, {\n    value: ctx\n  }, children);\n};\nElements.propTypes = {\n  stripe: prop_types__WEBPACK_IMPORTED_MODULE_1__.any,\n  options: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n};\nvar useElementsContextWithUseCase = function useElementsContextWithUseCase(useCaseMessage) {\n  var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ElementsContext);\n  return parseElementsContext(ctx, useCaseMessage);\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#useelements-hook\n */\n\nvar useElements = function useElements() {\n  var _useElementsContextWi = useElementsContextWithUseCase('calls useElements()'),\n      elements = _useElementsContextWi.elements;\n\n  return elements;\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#elements-consumer\n */\n\nvar ElementsConsumer = function ElementsConsumer(_ref2) {\n  var children = _ref2.children;\n  var ctx = useElementsContextWithUseCase('mounts <ElementsConsumer>'); // Assert to satisfy the busted React.FC return type (it should be ReactNode)\n\n  return children(ctx);\n};\nElementsConsumer.propTypes = {\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1__.func.isRequired\n};\n\nvar _excluded$1 = [\"on\", \"session\"];\nvar CheckoutSdkContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nCheckoutSdkContext.displayName = 'CheckoutSdkContext';\nvar parseCheckoutSdkContext = function parseCheckoutSdkContext(ctx, useCase) {\n  if (!ctx) {\n    throw new Error(\"Could not find CheckoutProvider context; You need to wrap the part of your app that \".concat(useCase, \" in an <CheckoutProvider> provider.\"));\n  }\n\n  return ctx;\n};\nvar CheckoutContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nCheckoutContext.displayName = 'CheckoutContext';\nvar extractCheckoutContextValue = function extractCheckoutContextValue(checkoutSdk, sessionState) {\n  if (!checkoutSdk) {\n    return null;\n  }\n\n  checkoutSdk.on;\n      checkoutSdk.session;\n      var actions = _objectWithoutProperties(checkoutSdk, _excluded$1);\n\n  if (!sessionState) {\n    return Object.assign(checkoutSdk.session(), actions);\n  }\n\n  return Object.assign(sessionState, actions);\n};\nvar INVALID_STRIPE_ERROR$1 = 'Invalid prop `stripe` supplied to `CheckoutProvider`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.';\nvar CheckoutProvider = function CheckoutProvider(_ref) {\n  var rawStripeProp = _ref.stripe,\n      options = _ref.options,\n      children = _ref.children;\n  var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return parseStripeProp(rawStripeProp, INVALID_STRIPE_ERROR$1);\n  }, [rawStripeProp]); // State used to trigger a re-render when sdk.session is updated\n\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      session = _React$useState2[0],\n      setSession = _React$useState2[1];\n\n  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState(function () {\n    return {\n      stripe: parsed.tag === 'sync' ? parsed.stripe : null,\n      checkoutSdk: null\n    };\n  }),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      ctx = _React$useState4[0],\n      setContext = _React$useState4[1];\n\n  var safeSetContext = function safeSetContext(stripe, checkoutSdk) {\n    setContext(function (ctx) {\n      if (ctx.stripe && ctx.checkoutSdk) {\n        return ctx;\n      }\n\n      return {\n        stripe: stripe,\n        checkoutSdk: checkoutSdk\n      };\n    });\n  }; // Ref used to avoid calling initCheckout multiple times when options changes\n\n\n  var initCheckoutCalledRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    var isMounted = true;\n\n    if (parsed.tag === 'async' && !ctx.stripe) {\n      parsed.stripePromise.then(function (stripe) {\n        if (stripe && isMounted && !initCheckoutCalledRef.current) {\n          // Only update context if the component is still mounted\n          // and stripe is not null. We allow stripe to be null to make\n          // handling SSR easier.\n          initCheckoutCalledRef.current = true;\n          stripe.initCheckout(options).then(function (checkoutSdk) {\n            if (checkoutSdk) {\n              safeSetContext(stripe, checkoutSdk);\n              checkoutSdk.on('change', setSession);\n            }\n          });\n        }\n      });\n    } else if (parsed.tag === 'sync' && parsed.stripe && !initCheckoutCalledRef.current) {\n      initCheckoutCalledRef.current = true;\n      parsed.stripe.initCheckout(options).then(function (checkoutSdk) {\n        if (checkoutSdk) {\n          safeSetContext(parsed.stripe, checkoutSdk);\n          checkoutSdk.on('change', setSession);\n        }\n      });\n    }\n\n    return function () {\n      isMounted = false;\n    };\n  }, [parsed, ctx, options, setSession]); // Warn on changes to stripe prop\n\n  var prevStripe = usePrevious(rawStripeProp);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (prevStripe !== null && prevStripe !== rawStripeProp) {\n      console.warn('Unsupported prop change on CheckoutProvider: You cannot change the `stripe` prop after setting it.');\n    }\n  }, [prevStripe, rawStripeProp]); // Apply updates to elements when options prop has relevant changes\n\n  var prevOptions = usePrevious(options);\n  var prevCheckoutSdk = usePrevious(ctx.checkoutSdk);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    var _prevOptions$elements, _options$elementsOpti, _prevOptions$elements2, _options$elementsOpti2;\n\n    // Ignore changes while checkout sdk is not initialized.\n    if (!ctx.checkoutSdk) {\n      return;\n    }\n\n    var hasSdkLoaded = Boolean(!prevCheckoutSdk && ctx.checkoutSdk); // Handle appearance changes\n\n    var previousAppearance = prevOptions === null || prevOptions === void 0 ? void 0 : (_prevOptions$elements = prevOptions.elementsOptions) === null || _prevOptions$elements === void 0 ? void 0 : _prevOptions$elements.appearance;\n    var currentAppearance = options === null || options === void 0 ? void 0 : (_options$elementsOpti = options.elementsOptions) === null || _options$elementsOpti === void 0 ? void 0 : _options$elementsOpti.appearance;\n    var hasAppearanceChanged = !isEqual(currentAppearance, previousAppearance);\n\n    if (currentAppearance && (hasAppearanceChanged || hasSdkLoaded)) {\n      ctx.checkoutSdk.changeAppearance(currentAppearance);\n    } // Handle fonts changes\n\n\n    var previousFonts = prevOptions === null || prevOptions === void 0 ? void 0 : (_prevOptions$elements2 = prevOptions.elementsOptions) === null || _prevOptions$elements2 === void 0 ? void 0 : _prevOptions$elements2.fonts;\n    var currentFonts = options === null || options === void 0 ? void 0 : (_options$elementsOpti2 = options.elementsOptions) === null || _options$elementsOpti2 === void 0 ? void 0 : _options$elementsOpti2.fonts;\n    var hasFontsChanged = !isEqual(previousFonts, currentFonts);\n\n    if (currentFonts && (hasFontsChanged || hasSdkLoaded)) {\n      ctx.checkoutSdk.loadFonts(currentFonts);\n    }\n  }, [options, prevOptions, ctx.checkoutSdk, prevCheckoutSdk]); // Attach react-stripe-js version to stripe.js instance\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    registerWithStripeJs(ctx.stripe);\n  }, [ctx.stripe]);\n  var checkoutContextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return extractCheckoutContextValue(ctx.checkoutSdk, session);\n  }, [ctx.checkoutSdk, session]);\n\n  if (!ctx.checkoutSdk) {\n    return null;\n  }\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(CheckoutSdkContext.Provider, {\n    value: ctx\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(CheckoutContext.Provider, {\n    value: checkoutContextValue\n  }, children));\n};\nCheckoutProvider.propTypes = {\n  stripe: prop_types__WEBPACK_IMPORTED_MODULE_1__.any,\n  options: prop_types__WEBPACK_IMPORTED_MODULE_1__.shape({\n    fetchClientSecret: prop_types__WEBPACK_IMPORTED_MODULE_1__.func.isRequired,\n    elementsOptions: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n  }).isRequired\n};\nvar useCheckoutSdkContextWithUseCase = function useCheckoutSdkContextWithUseCase(useCaseString) {\n  var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CheckoutSdkContext);\n  return parseCheckoutSdkContext(ctx, useCaseString);\n};\nvar useElementsOrCheckoutSdkContextWithUseCase = function useElementsOrCheckoutSdkContextWithUseCase(useCaseString) {\n  var checkoutSdkContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CheckoutSdkContext);\n  var elementsContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ElementsContext);\n\n  if (checkoutSdkContext && elementsContext) {\n    throw new Error(\"You cannot wrap the part of your app that \".concat(useCaseString, \" in both <CheckoutProvider> and <Elements> providers.\"));\n  }\n\n  if (checkoutSdkContext) {\n    return parseCheckoutSdkContext(checkoutSdkContext, useCaseString);\n  }\n\n  return parseElementsContext(elementsContext, useCaseString);\n};\nvar useCheckout = function useCheckout() {\n  // ensure it's in CheckoutProvider\n  useCheckoutSdkContextWithUseCase('calls useCheckout()');\n  var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CheckoutContext);\n\n  if (!ctx) {\n    throw new Error('Could not find Checkout Context; You need to wrap the part of your app that calls useCheckout() in an <CheckoutProvider> provider.');\n  }\n\n  return ctx;\n};\n\nvar _excluded = [\"mode\"];\n\nvar capitalized = function capitalized(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nvar createElementComponent = function createElementComponent(type, isServer) {\n  var displayName = \"\".concat(capitalized(type), \"Element\");\n\n  var ClientElement = function ClientElement(_ref) {\n    var id = _ref.id,\n        className = _ref.className,\n        _ref$options = _ref.options,\n        options = _ref$options === void 0 ? {} : _ref$options,\n        onBlur = _ref.onBlur,\n        onFocus = _ref.onFocus,\n        onReady = _ref.onReady,\n        onChange = _ref.onChange,\n        onEscape = _ref.onEscape,\n        onClick = _ref.onClick,\n        onLoadError = _ref.onLoadError,\n        onLoaderStart = _ref.onLoaderStart,\n        onNetworksChange = _ref.onNetworksChange,\n        onConfirm = _ref.onConfirm,\n        onCancel = _ref.onCancel,\n        onShippingAddressChange = _ref.onShippingAddressChange,\n        onShippingRateChange = _ref.onShippingRateChange,\n        onSavedPaymentMethodRemove = _ref.onSavedPaymentMethodRemove,\n        onSavedPaymentMethodUpdate = _ref.onSavedPaymentMethodUpdate;\n    var ctx = useElementsOrCheckoutSdkContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n    var elements = 'elements' in ctx ? ctx.elements : null;\n    var checkoutSdk = 'checkoutSdk' in ctx ? ctx.checkoutSdk : null;\n\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(null),\n        _React$useState2 = _slicedToArray(_React$useState, 2),\n        element = _React$useState2[0],\n        setElement = _React$useState2[1];\n\n    var elementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    var domNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null); // For every event where the merchant provides a callback, call element.on\n    // with that callback. If the merchant ever changes the callback, removes\n    // the old callback with element.off and then call element.on with the new one.\n\n    useAttachEvent(element, 'blur', onBlur);\n    useAttachEvent(element, 'focus', onFocus);\n    useAttachEvent(element, 'escape', onEscape);\n    useAttachEvent(element, 'click', onClick);\n    useAttachEvent(element, 'loaderror', onLoadError);\n    useAttachEvent(element, 'loaderstart', onLoaderStart);\n    useAttachEvent(element, 'networkschange', onNetworksChange);\n    useAttachEvent(element, 'confirm', onConfirm);\n    useAttachEvent(element, 'cancel', onCancel);\n    useAttachEvent(element, 'shippingaddresschange', onShippingAddressChange);\n    useAttachEvent(element, 'shippingratechange', onShippingRateChange);\n    useAttachEvent(element, 'savedpaymentmethodremove', onSavedPaymentMethodRemove);\n    useAttachEvent(element, 'savedpaymentmethodupdate', onSavedPaymentMethodUpdate);\n    useAttachEvent(element, 'change', onChange);\n    var readyCallback;\n\n    if (onReady) {\n      if (type === 'expressCheckout') {\n        // Passes through the event, which includes visible PM types\n        readyCallback = onReady;\n      } else {\n        // For other Elements, pass through the Element itself.\n        readyCallback = function readyCallback() {\n          onReady(element);\n        };\n      }\n    }\n\n    useAttachEvent(element, 'ready', readyCallback);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n      if (elementRef.current === null && domNode.current !== null && (elements || checkoutSdk)) {\n        var newElement = null;\n\n        if (checkoutSdk) {\n          switch (type) {\n            case 'payment':\n              newElement = checkoutSdk.createPaymentElement(options);\n              break;\n\n            case 'address':\n              if ('mode' in options) {\n                var mode = options.mode,\n                    restOptions = _objectWithoutProperties(options, _excluded);\n\n                if (mode === 'shipping') {\n                  newElement = checkoutSdk.createShippingAddressElement(restOptions);\n                } else if (mode === 'billing') {\n                  newElement = checkoutSdk.createBillingAddressElement(restOptions);\n                } else {\n                  throw new Error(\"Invalid options.mode. mode must be 'billing' or 'shipping'.\");\n                }\n              } else {\n                throw new Error(\"You must supply options.mode. mode must be 'billing' or 'shipping'.\");\n              }\n\n              break;\n\n            case 'expressCheckout':\n              newElement = checkoutSdk.createExpressCheckoutElement(options);\n              break;\n\n            case 'currencySelector':\n              newElement = checkoutSdk.createCurrencySelectorElement();\n              break;\n\n            case 'taxId':\n              newElement = checkoutSdk.createTaxIdElement(options);\n              break;\n\n            default:\n              throw new Error(\"Invalid Element type \".concat(displayName, \". You must use either the <PaymentElement />, <AddressElement options={{mode: 'shipping'}} />, <AddressElement options={{mode: 'billing'}} />, or <ExpressCheckoutElement />.\"));\n          }\n        } else if (elements) {\n          newElement = elements.create(type, options);\n        } // Store element in a ref to ensure it's _immediately_ available in cleanup hooks in StrictMode\n\n\n        elementRef.current = newElement; // Store element in state to facilitate event listener attachment\n\n        setElement(newElement);\n\n        if (newElement) {\n          newElement.mount(domNode.current);\n        }\n      }\n    }, [elements, checkoutSdk, options]);\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n      if (!elementRef.current) {\n        return;\n      }\n\n      var updates = extractAllowedOptionsUpdates(options, prevOptions, ['paymentRequest']);\n\n      if (updates && 'update' in elementRef.current) {\n        elementRef.current.update(updates);\n      }\n    }, [options, prevOptions]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n      return function () {\n        if (elementRef.current && typeof elementRef.current.destroy === 'function') {\n          try {\n            elementRef.current.destroy();\n            elementRef.current = null;\n          } catch (error) {// Do nothing\n          }\n        }\n      };\n    }, []);\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      id: id,\n      className: className,\n      ref: domNode\n    });\n  }; // Only render the Element wrapper in a server environment.\n\n\n  var ServerElement = function ServerElement(props) {\n    useElementsOrCheckoutSdkContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n    var id = props.id,\n        className = props.className;\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      id: id,\n      className: className\n    });\n  };\n\n  var Element = isServer ? ServerElement : ClientElement;\n  Element.propTypes = {\n    id: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,\n    className: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,\n    onChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onBlur: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onFocus: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onReady: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onEscape: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onClick: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onLoadError: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onLoaderStart: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onNetworksChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onConfirm: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onCancel: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onShippingAddressChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onShippingRateChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onSavedPaymentMethodRemove: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onSavedPaymentMethodUpdate: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    options: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n  };\n  Element.displayName = displayName;\n  Element.__elementType = type;\n  return Element;\n};\n\nvar isServer = typeof window === 'undefined';\n\nvar EmbeddedCheckoutContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nEmbeddedCheckoutContext.displayName = 'EmbeddedCheckoutProviderContext';\nvar useEmbeddedCheckoutContext = function useEmbeddedCheckoutContext() {\n  var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(EmbeddedCheckoutContext);\n\n  if (!ctx) {\n    throw new Error('<EmbeddedCheckout> must be used within <EmbeddedCheckoutProvider>');\n  }\n\n  return ctx;\n};\nvar INVALID_STRIPE_ERROR = 'Invalid prop `stripe` supplied to `EmbeddedCheckoutProvider`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.';\nvar EmbeddedCheckoutProvider = function EmbeddedCheckoutProvider(_ref) {\n  var rawStripeProp = _ref.stripe,\n      options = _ref.options,\n      children = _ref.children;\n  var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return parseStripeProp(rawStripeProp, INVALID_STRIPE_ERROR);\n  }, [rawStripeProp]);\n  var embeddedCheckoutPromise = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  var loadedStripe = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    embeddedCheckout: null\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      ctx = _React$useState2[0],\n      setContext = _React$useState2[1];\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    // Don't support any ctx updates once embeddedCheckout or stripe is set.\n    if (loadedStripe.current || embeddedCheckoutPromise.current) {\n      return;\n    }\n\n    var setStripeAndInitEmbeddedCheckout = function setStripeAndInitEmbeddedCheckout(stripe) {\n      if (loadedStripe.current || embeddedCheckoutPromise.current) return;\n      loadedStripe.current = stripe;\n      embeddedCheckoutPromise.current = loadedStripe.current.initEmbeddedCheckout(options).then(function (embeddedCheckout) {\n        setContext({\n          embeddedCheckout: embeddedCheckout\n        });\n      });\n    }; // For an async stripePromise, store it once resolved\n\n\n    if (parsed.tag === 'async' && !loadedStripe.current && (options.clientSecret || options.fetchClientSecret)) {\n      parsed.stripePromise.then(function (stripe) {\n        if (stripe) {\n          setStripeAndInitEmbeddedCheckout(stripe);\n        }\n      });\n    } else if (parsed.tag === 'sync' && !loadedStripe.current && (options.clientSecret || options.fetchClientSecret)) {\n      // Or, handle a sync stripe instance going from null -> populated\n      setStripeAndInitEmbeddedCheckout(parsed.stripe);\n    }\n  }, [parsed, options, ctx, loadedStripe]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    // cleanup on unmount\n    return function () {\n      // If embedded checkout is fully initialized, destroy it.\n      if (ctx.embeddedCheckout) {\n        embeddedCheckoutPromise.current = null;\n        ctx.embeddedCheckout.destroy();\n      } else if (embeddedCheckoutPromise.current) {\n        // If embedded checkout is still initializing, destroy it once\n        // it's done. This could be caused by unmounting very quickly\n        // after mounting.\n        embeddedCheckoutPromise.current.then(function () {\n          embeddedCheckoutPromise.current = null;\n\n          if (ctx.embeddedCheckout) {\n            ctx.embeddedCheckout.destroy();\n          }\n        });\n      }\n    };\n  }, [ctx.embeddedCheckout]); // Attach react-stripe-js version to stripe.js instance\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    registerWithStripeJs(loadedStripe);\n  }, [loadedStripe]); // Warn on changes to stripe prop.\n  // The stripe prop value can only go from null to non-null once and\n  // can't be changed after that.\n\n  var prevStripe = usePrevious(rawStripeProp);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (prevStripe !== null && prevStripe !== rawStripeProp) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the `stripe` prop after setting it.');\n    }\n  }, [prevStripe, rawStripeProp]); // Warn on changes to options.\n\n  var prevOptions = usePrevious(options);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (prevOptions == null) {\n      return;\n    }\n\n    if (options == null) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot unset options after setting them.');\n      return;\n    }\n\n    if (options.clientSecret === undefined && options.fetchClientSecret === undefined) {\n      console.warn('Invalid props passed to EmbeddedCheckoutProvider: You must provide one of either `options.fetchClientSecret` or `options.clientSecret`.');\n    }\n\n    if (prevOptions.clientSecret != null && options.clientSecret !== prevOptions.clientSecret) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the client secret after setting it. Unmount and create a new instance of EmbeddedCheckoutProvider instead.');\n    }\n\n    if (prevOptions.fetchClientSecret != null && options.fetchClientSecret !== prevOptions.fetchClientSecret) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot change fetchClientSecret after setting it. Unmount and create a new instance of EmbeddedCheckoutProvider instead.');\n    }\n\n    if (prevOptions.onComplete != null && options.onComplete !== prevOptions.onComplete) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onComplete option after setting it.');\n    }\n\n    if (prevOptions.onShippingDetailsChange != null && options.onShippingDetailsChange !== prevOptions.onShippingDetailsChange) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onShippingDetailsChange option after setting it.');\n    }\n\n    if (prevOptions.onLineItemsChange != null && options.onLineItemsChange !== prevOptions.onLineItemsChange) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onLineItemsChange option after setting it.');\n    }\n  }, [prevOptions, options]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(EmbeddedCheckoutContext.Provider, {\n    value: ctx\n  }, children);\n};\n\nvar EmbeddedCheckoutClientElement = function EmbeddedCheckoutClientElement(_ref) {\n  var id = _ref.id,\n      className = _ref.className;\n\n  var _useEmbeddedCheckoutC = useEmbeddedCheckoutContext(),\n      embeddedCheckout = _useEmbeddedCheckoutC.embeddedCheckout;\n\n  var isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  var domNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n    if (!isMounted.current && embeddedCheckout && domNode.current !== null) {\n      embeddedCheckout.mount(domNode.current);\n      isMounted.current = true;\n    } // Clean up on unmount\n\n\n    return function () {\n      if (isMounted.current && embeddedCheckout) {\n        try {\n          embeddedCheckout.unmount();\n          isMounted.current = false;\n        } catch (e) {// Do nothing.\n          // Parent effects are destroyed before child effects, so\n          // in cases where both the EmbeddedCheckoutProvider and\n          // the EmbeddedCheckout component are removed at the same\n          // time, the embeddedCheckout instance will be destroyed,\n          // which causes an error when calling unmount.\n        }\n      }\n    };\n  }, [embeddedCheckout]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    ref: domNode,\n    id: id,\n    className: className\n  });\n}; // Only render the wrapper in a server environment.\n\n\nvar EmbeddedCheckoutServerElement = function EmbeddedCheckoutServerElement(_ref2) {\n  var id = _ref2.id,\n      className = _ref2.className;\n  // Validate that we are in the right context by calling useEmbeddedCheckoutContext.\n  useEmbeddedCheckoutContext();\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    id: id,\n    className: className\n  });\n};\n\nvar EmbeddedCheckout = isServer ? EmbeddedCheckoutServerElement : EmbeddedCheckoutClientElement;\n\n/**\n * @docs https://stripe.com/docs/stripe-js/react#usestripe-hook\n */\n\nvar useStripe = function useStripe() {\n  var _useElementsOrCheckou = useElementsOrCheckoutSdkContextWithUseCase('calls useStripe()'),\n      stripe = _useElementsOrCheckou.stripe;\n\n  return stripe;\n};\n\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar AuBankAccountElement = createElementComponent('auBankAccount', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar CardElement = createElementComponent('card', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar CardNumberElement = createElementComponent('cardNumber', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar CardExpiryElement = createElementComponent('cardExpiry', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar CardCvcElement = createElementComponent('cardCvc', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar FpxBankElement = createElementComponent('fpxBank', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar IbanElement = createElementComponent('iban', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar IdealBankElement = createElementComponent('idealBank', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar P24BankElement = createElementComponent('p24Bank', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar EpsBankElement = createElementComponent('epsBank', isServer);\nvar PaymentElement = createElementComponent('payment', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar ExpressCheckoutElement = createElementComponent('expressCheckout', isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n */\n\nvar CurrencySelectorElement = createElementComponent('currencySelector', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar PaymentRequestButtonElement = createElementComponent('paymentRequestButton', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar LinkAuthenticationElement = createElementComponent('linkAuthentication', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar AddressElement = createElementComponent('address', isServer);\n/**\n * @deprecated\n * Use `AddressElement` instead.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar ShippingAddressElement = createElementComponent('shippingAddress', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar PaymentMethodMessagingElement = createElementComponent('paymentMethodMessaging', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar AffirmMessageElement = createElementComponent('affirmMessage', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar AfterpayClearpayMessageElement = createElementComponent('afterpayClearpayMessage', isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n */\n\nvar TaxIdElement = createElementComponent('taxId', isServer);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvZGlzdC9yZWFjdC1zdHJpcGUuZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBCO0FBQ1M7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMseUNBQVksTUFBTTtBQUNoQzs7QUFFQSxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxZQUFZLHlDQUFZO0FBQ3hCLEVBQUUsNENBQWU7QUFDakI7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsa0JBQWtCLEtBQUssb0JBQW9CO0FBQ3RGLEdBQUc7QUFDSDs7QUFFQSxtT0FBbU87QUFDbk87QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLG1DQUFtQyxnREFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMENBQWE7QUFDNUI7QUFDQSxHQUFHLG9CQUFvQjs7QUFFdkIsd0JBQXdCLDJDQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDRDQUFlO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMkJBQTJCOztBQUU5QjtBQUNBLEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnQ0FBZ0M7O0FBRW5DO0FBQ0EsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5Q0FBeUM7O0FBRTVDLEVBQUUsNENBQWU7QUFDakI7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLGdEQUFtQjtBQUN6QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSwyQ0FBYTtBQUN2QixXQUFXLDhDQUFnQjtBQUMzQjtBQUNBO0FBQ0EsWUFBWSw2Q0FBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRDQUFjO0FBQzFCOztBQUVBO0FBQ0Esc0NBQXNDLGdEQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxnREFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQ0FBYTtBQUM1QjtBQUNBLEdBQUcsb0JBQW9COztBQUV2Qix3QkFBd0IsMkNBQWM7QUFDdEM7QUFDQTtBQUNBOztBQUVBLHlCQUF5QiwyQ0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxLQUFLOzs7QUFHTCw4QkFBOEIseUNBQVk7QUFDMUMsRUFBRSw0Q0FBZTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHVDQUF1Qzs7QUFFMUM7QUFDQSxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0NBQWdDOztBQUVuQztBQUNBO0FBQ0EsRUFBRSw0Q0FBZTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNkRBQTZEOztBQUVoRSxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0EsR0FBRztBQUNILDZCQUE2QiwwQ0FBYTtBQUMxQztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnREFBbUI7QUFDekM7QUFDQSxHQUFHLGVBQWUsZ0RBQW1CO0FBQ3JDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxVQUFVLDJDQUFhO0FBQ3ZCLFdBQVcsNkNBQWU7QUFDMUIsdUJBQXVCLDRDQUFjO0FBQ3JDLHFCQUFxQiw4Q0FBZ0I7QUFDckMsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLDZDQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkNBQWdCO0FBQzNDLHdCQUF3Qiw2Q0FBZ0I7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQWdCOztBQUU1QjtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsMkNBQWM7QUFDeEM7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix5Q0FBWTtBQUNqQyxrQkFBa0IseUNBQVksUUFBUTtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLGtEQUFxQjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtSkFBbUosbUJBQW1CLDhCQUE4QixrQkFBa0I7QUFDdE47QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVOzs7QUFHVix5Q0FBeUM7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksa0RBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixnREFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFtQjtBQUMzQztBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxRQUFRLDhDQUFnQjtBQUN4QixlQUFlLDhDQUFnQjtBQUMvQixjQUFjLDRDQUFjO0FBQzVCLFlBQVksNENBQWM7QUFDMUIsYUFBYSw0Q0FBYztBQUMzQixhQUFhLDRDQUFjO0FBQzNCLGNBQWMsNENBQWM7QUFDNUIsYUFBYSw0Q0FBYztBQUMzQixpQkFBaUIsNENBQWM7QUFDL0IsbUJBQW1CLDRDQUFjO0FBQ2pDLHNCQUFzQiw0Q0FBYztBQUNwQyxlQUFlLDRDQUFjO0FBQzdCLGNBQWMsNENBQWM7QUFDNUIsNkJBQTZCLDRDQUFjO0FBQzNDLDBCQUEwQiw0Q0FBYztBQUN4QyxnQ0FBZ0MsNENBQWM7QUFDOUMsZ0NBQWdDLDRDQUFjO0FBQzlDLGFBQWEsOENBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDLGdEQUFtQjtBQUM5RDtBQUNBO0FBQ0EsWUFBWSw2Q0FBZ0I7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMENBQWE7QUFDNUI7QUFDQSxHQUFHO0FBQ0gsZ0NBQWdDLHlDQUFZO0FBQzVDLHFCQUFxQix5Q0FBWTs7QUFFakMsd0JBQXdCLDJDQUFjO0FBQ3RDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHLDJCQUEyQjs7QUFFOUIsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBLEdBQUcsbUJBQW1CO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0NBQWdDOztBQUVuQztBQUNBLEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQixnREFBbUI7QUFDekM7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHlDQUFZO0FBQzlCLGdCQUFnQix5Q0FBWTtBQUM1QixFQUFFLGtEQUFxQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLGdEQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnREFBbUI7QUFDekM7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVxakIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wcmF0aGFtZ3VwdGEvRGVza3RvcC9BcHBWZXJzYWwvQVNPV0lOL0FTT1dpbk5leHQvbm9kZV9tb2R1bGVzL0BzdHJpcGUvcmVhY3Qtc3RyaXBlLWpzL2Rpc3QvcmVhY3Qtc3RyaXBlLmVzbS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcblxuICAgIGlmIChlbnVtZXJhYmxlT25seSkge1xuICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG5cbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gYXJyICYmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl0pO1xuXG4gIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuXG4gIHZhciBfcywgX2U7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbnZhciB1c2VBdHRhY2hFdmVudCA9IGZ1bmN0aW9uIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsIGV2ZW50LCBjYikge1xuICB2YXIgY2JEZWZpbmVkID0gISFjYjtcbiAgdmFyIGNiUmVmID0gUmVhY3QudXNlUmVmKGNiKTsgLy8gSW4gbWFueSBpbnRlZ3JhdGlvbnMgdGhlIGNhbGxiYWNrIHByb3AgY2hhbmdlcyBvbiBlYWNoIHJlbmRlci5cbiAgLy8gVXNpbmcgYSByZWYgc2F2ZXMgdXMgZnJvbSBjYWxsaW5nIGVsZW1lbnQub24vLm9mZiBldmVyeSByZW5kZXIuXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBjYlJlZi5jdXJyZW50ID0gY2I7XG4gIH0sIFtjYl0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2JEZWZpbmVkIHx8ICFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gICAgfVxuXG4gICAgdmFyIGRlY29yYXRlZENiID0gZnVuY3Rpb24gZGVjb3JhdGVkQ2IoKSB7XG4gICAgICBpZiAoY2JSZWYuY3VycmVudCkge1xuICAgICAgICBjYlJlZi5jdXJyZW50LmFwcGx5KGNiUmVmLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBlbGVtZW50Lm9uKGV2ZW50LCBkZWNvcmF0ZWRDYik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQub2ZmKGV2ZW50LCBkZWNvcmF0ZWRDYik7XG4gICAgfTtcbiAgfSwgW2NiRGVmaW5lZCwgZXZlbnQsIGVsZW1lbnQsIGNiUmVmXSk7XG59O1xuXG52YXIgdXNlUHJldmlvdXMgPSBmdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xuICB2YXIgcmVmID0gUmVhY3QudXNlUmVmKHZhbHVlKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufTtcblxudmFyIGlzVW5rbm93bk9iamVjdCA9IGZ1bmN0aW9uIGlzVW5rbm93bk9iamVjdChyYXcpIHtcbiAgcmV0dXJuIHJhdyAhPT0gbnVsbCAmJiBfdHlwZW9mKHJhdykgPT09ICdvYmplY3QnO1xufTtcbnZhciBpc1Byb21pc2UgPSBmdW5jdGlvbiBpc1Byb21pc2UocmF3KSB7XG4gIHJldHVybiBpc1Vua25vd25PYmplY3QocmF3KSAmJiB0eXBlb2YgcmF3LnRoZW4gPT09ICdmdW5jdGlvbic7XG59OyAvLyBXZSBhcmUgdXNpbmcgdHlwZXMgdG8gZW5mb3JjZSB0aGUgYHN0cmlwZWAgcHJvcCBpbiB0aGlzIGxpYixcbi8vIGJ1dCBpbiBhbiB1bnR5cGVkIGludGVncmF0aW9uIGBzdHJpcGVgIGNvdWxkIGJlIGFueXRoaW5nLCBzbyB3ZSBuZWVkXG4vLyB0byBkbyBzb21lIHNhbml0eSB2YWxpZGF0aW9uIHRvIHByZXZlbnQgdHlwZSBlcnJvcnMuXG5cbnZhciBpc1N0cmlwZSA9IGZ1bmN0aW9uIGlzU3RyaXBlKHJhdykge1xuICByZXR1cm4gaXNVbmtub3duT2JqZWN0KHJhdykgJiYgdHlwZW9mIHJhdy5lbGVtZW50cyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmF3LmNyZWF0ZVRva2VuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByYXcuY3JlYXRlUGF5bWVudE1ldGhvZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmF3LmNvbmZpcm1DYXJkUGF5bWVudCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBQTEFJTl9PQkpFQ1RfU1RSID0gJ1tvYmplY3QgT2JqZWN0XSc7XG52YXIgaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgaWYgKCFpc1Vua25vd25PYmplY3QobGVmdCkgfHwgIWlzVW5rbm93bk9iamVjdChyaWdodCkpIHtcbiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIH1cblxuICB2YXIgbGVmdEFycmF5ID0gQXJyYXkuaXNBcnJheShsZWZ0KTtcbiAgdmFyIHJpZ2h0QXJyYXkgPSBBcnJheS5pc0FycmF5KHJpZ2h0KTtcbiAgaWYgKGxlZnRBcnJheSAhPT0gcmlnaHRBcnJheSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgbGVmdFBsYWluT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGxlZnQpID09PSBQTEFJTl9PQkpFQ1RfU1RSO1xuICB2YXIgcmlnaHRQbGFpbk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyaWdodCkgPT09IFBMQUlOX09CSkVDVF9TVFI7XG4gIGlmIChsZWZ0UGxhaW5PYmplY3QgIT09IHJpZ2h0UGxhaW5PYmplY3QpIHJldHVybiBmYWxzZTsgLy8gbm90IHN1cmUgd2hhdCBzb3J0IG9mIHNwZWNpYWwgb2JqZWN0IHRoaXMgaXMgKHJlZ2V4cCBpcyBvbmUgb3B0aW9uKSwgc29cbiAgLy8gZmFsbGJhY2sgdG8gcmVmZXJlbmNlIGNoZWNrLlxuXG4gIGlmICghbGVmdFBsYWluT2JqZWN0ICYmICFsZWZ0QXJyYXkpIHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgdmFyIGxlZnRLZXlzID0gT2JqZWN0LmtleXMobGVmdCk7XG4gIHZhciByaWdodEtleXMgPSBPYmplY3Qua2V5cyhyaWdodCk7XG4gIGlmIChsZWZ0S2V5cy5sZW5ndGggIT09IHJpZ2h0S2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgdmFyIGtleVNldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBrZXlTZXRbbGVmdEtleXNbaV1dID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCByaWdodEtleXMubGVuZ3RoOyBfaSArPSAxKSB7XG4gICAga2V5U2V0W3JpZ2h0S2V5c1tfaV1dID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBhbGxLZXlzID0gT2JqZWN0LmtleXMoa2V5U2V0KTtcblxuICBpZiAoYWxsS2V5cy5sZW5ndGggIT09IGxlZnRLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsID0gbGVmdDtcbiAgdmFyIHIgPSByaWdodDtcblxuICB2YXIgcHJlZCA9IGZ1bmN0aW9uIHByZWQoa2V5KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobFtrZXldLCByW2tleV0pO1xuICB9O1xuXG4gIHJldHVybiBhbGxLZXlzLmV2ZXJ5KHByZWQpO1xufTtcblxudmFyIGV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMgPSBmdW5jdGlvbiBleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzKG9wdGlvbnMsIHByZXZPcHRpb25zLCBpbW11dGFibGVLZXlzKSB7XG4gIGlmICghaXNVbmtub3duT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucykucmVkdWNlKGZ1bmN0aW9uIChuZXdPcHRpb25zLCBrZXkpIHtcbiAgICB2YXIgaXNVcGRhdGVkID0gIWlzVW5rbm93bk9iamVjdChwcmV2T3B0aW9ucykgfHwgIWlzRXF1YWwob3B0aW9uc1trZXldLCBwcmV2T3B0aW9uc1trZXldKTtcblxuICAgIGlmIChpbW11dGFibGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGlmIChpc1VwZGF0ZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2U6IG9wdGlvbnMuXCIuY29uY2F0KGtleSwgXCIgaXMgbm90IGEgbXV0YWJsZSBwcm9wZXJ0eS5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3T3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoIWlzVXBkYXRlZCkge1xuICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBuZXdPcHRpb25zIHx8IHt9KSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBvcHRpb25zW2tleV0pKTtcbiAgfSwgbnVsbCk7XG59O1xuXG52YXIgSU5WQUxJRF9TVFJJUEVfRVJST1IkMiA9ICdJbnZhbGlkIHByb3AgYHN0cmlwZWAgc3VwcGxpZWQgdG8gYEVsZW1lbnRzYC4gV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBgbG9hZFN0cmlwZWAgdXRpbGl0eSBmcm9tIGBAc3RyaXBlL3N0cmlwZS1qc2AuIFNlZSBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudHMtcHJvcHMtc3RyaXBlIGZvciBkZXRhaWxzLic7IC8vIFdlIGFyZSB1c2luZyB0eXBlcyB0byBlbmZvcmNlIHRoZSBgc3RyaXBlYCBwcm9wIGluIHRoaXMgbGliLCBidXQgaW4gYSByZWFsXG4vLyBpbnRlZ3JhdGlvbiBgc3RyaXBlYCBjb3VsZCBiZSBhbnl0aGluZywgc28gd2UgbmVlZCB0byBkbyBzb21lIHNhbml0eVxuLy8gdmFsaWRhdGlvbiB0byBwcmV2ZW50IHR5cGUgZXJyb3JzLlxuXG52YXIgdmFsaWRhdGVTdHJpcGUgPSBmdW5jdGlvbiB2YWxpZGF0ZVN0cmlwZShtYXliZVN0cmlwZSkge1xuICB2YXIgZXJyb3JNc2cgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IElOVkFMSURfU1RSSVBFX0VSUk9SJDI7XG5cbiAgaWYgKG1heWJlU3RyaXBlID09PSBudWxsIHx8IGlzU3RyaXBlKG1heWJlU3RyaXBlKSkge1xuICAgIHJldHVybiBtYXliZVN0cmlwZTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG59O1xuXG52YXIgcGFyc2VTdHJpcGVQcm9wID0gZnVuY3Rpb24gcGFyc2VTdHJpcGVQcm9wKHJhdykge1xuICB2YXIgZXJyb3JNc2cgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IElOVkFMSURfU1RSSVBFX0VSUk9SJDI7XG5cbiAgaWYgKGlzUHJvbWlzZShyYXcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZzogJ2FzeW5jJyxcbiAgICAgIHN0cmlwZVByb21pc2U6IFByb21pc2UucmVzb2x2ZShyYXcpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVTdHJpcGUocmVzdWx0LCBlcnJvck1zZyk7XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICB2YXIgc3RyaXBlID0gdmFsaWRhdGVTdHJpcGUocmF3LCBlcnJvck1zZyk7XG5cbiAgaWYgKHN0cmlwZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6ICdlbXB0eSdcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0YWc6ICdzeW5jJyxcbiAgICBzdHJpcGU6IHN0cmlwZVxuICB9O1xufTtcblxudmFyIHJlZ2lzdGVyV2l0aFN0cmlwZUpzID0gZnVuY3Rpb24gcmVnaXN0ZXJXaXRoU3RyaXBlSnMoc3RyaXBlKSB7XG4gIGlmICghc3RyaXBlIHx8ICFzdHJpcGUuX3JlZ2lzdGVyV3JhcHBlciB8fCAhc3RyaXBlLnJlZ2lzdGVyQXBwSW5mbykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0cmlwZS5fcmVnaXN0ZXJXcmFwcGVyKHtcbiAgICBuYW1lOiAncmVhY3Qtc3RyaXBlLWpzJyxcbiAgICB2ZXJzaW9uOiBcIjMuMTAuMFwiXG4gIH0pO1xuXG4gIHN0cmlwZS5yZWdpc3RlckFwcEluZm8oe1xuICAgIG5hbWU6ICdyZWFjdC1zdHJpcGUtanMnLFxuICAgIHZlcnNpb246IFwiMy4xMC4wXCIsXG4gICAgdXJsOiAnaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0J1xuICB9KTtcbn07XG5cbnZhciBFbGVtZW50c0NvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkVsZW1lbnRzQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdFbGVtZW50c0NvbnRleHQnO1xudmFyIHBhcnNlRWxlbWVudHNDb250ZXh0ID0gZnVuY3Rpb24gcGFyc2VFbGVtZW50c0NvbnRleHQoY3R4LCB1c2VDYXNlKSB7XG4gIGlmICghY3R4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgRWxlbWVudHMgY29udGV4dDsgWW91IG5lZWQgdG8gd3JhcCB0aGUgcGFydCBvZiB5b3VyIGFwcCB0aGF0IFwiLmNvbmNhdCh1c2VDYXNlLCBcIiBpbiBhbiA8RWxlbWVudHM+IHByb3ZpZGVyLlwiKSk7XG4gIH1cblxuICByZXR1cm4gY3R4O1xufTtcbi8qKlxuICogVGhlIGBFbGVtZW50c2AgcHJvdmlkZXIgYWxsb3dzIHlvdSB0byB1c2UgW0VsZW1lbnQgY29tcG9uZW50c10oaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50cykgYW5kIGFjY2VzcyB0aGUgW1N0cmlwZSBvYmplY3RdKGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL2pzL2luaXRpYWxpemluZykgaW4gYW55IG5lc3RlZCBjb21wb25lbnQuXG4gKiBSZW5kZXIgYW4gYEVsZW1lbnRzYCBwcm92aWRlciBhdCB0aGUgcm9vdCBvZiB5b3VyIFJlYWN0IGFwcCBzbyB0aGF0IGl0IGlzIGF2YWlsYWJsZSBldmVyeXdoZXJlIHlvdSBuZWVkIGl0LlxuICpcbiAqIFRvIHVzZSB0aGUgYEVsZW1lbnRzYCBwcm92aWRlciwgY2FsbCBgbG9hZFN0cmlwZWAgZnJvbSBgQHN0cmlwZS9zdHJpcGUtanNgIHdpdGggeW91ciBwdWJsaXNoYWJsZSBrZXkuXG4gKiBUaGUgYGxvYWRTdHJpcGVgIGZ1bmN0aW9uIHdpbGwgYXN5bmNocm9ub3VzbHkgbG9hZCB0aGUgU3RyaXBlLmpzIHNjcmlwdCBhbmQgaW5pdGlhbGl6ZSBhIGBTdHJpcGVgIG9iamVjdC5cbiAqIFBhc3MgdGhlIHJldHVybmVkIGBQcm9taXNlYCB0byBgRWxlbWVudHNgLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vZG9jcy5zdHJpcGUuY29tL3Nka3Mvc3RyaXBlanMtcmVhY3Q/dWk9ZWxlbWVudHMjZWxlbWVudHMtcHJvdmlkZXJcbiAqL1xuXG52YXIgRWxlbWVudHMgPSBmdW5jdGlvbiBFbGVtZW50cyhfcmVmKSB7XG4gIHZhciByYXdTdHJpcGVQcm9wID0gX3JlZi5zdHJpcGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICB2YXIgcGFyc2VkID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcnNlU3RyaXBlUHJvcChyYXdTdHJpcGVQcm9wKTtcbiAgfSwgW3Jhd1N0cmlwZVByb3BdKTsgLy8gRm9yIGEgc3luYyBzdHJpcGUgaW5zdGFuY2UsIGluaXRpYWxpemUgaW50byBjb250ZXh0XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyaXBlOiBwYXJzZWQudGFnID09PSAnc3luYycgPyBwYXJzZWQuc3RyaXBlIDogbnVsbCxcbiAgICAgIGVsZW1lbnRzOiBwYXJzZWQudGFnID09PSAnc3luYycgPyBwYXJzZWQuc3RyaXBlLmVsZW1lbnRzKG9wdGlvbnMpIDogbnVsbFxuICAgIH07XG4gIH0pLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBjdHggPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0Q29udGV4dCA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXNNb3VudGVkID0gdHJ1ZTtcblxuICAgIHZhciBzYWZlU2V0Q29udGV4dCA9IGZ1bmN0aW9uIHNhZmVTZXRDb250ZXh0KHN0cmlwZSkge1xuICAgICAgc2V0Q29udGV4dChmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIC8vIG5vLW9wIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHN0cmlwZSBpbnN0YW5jZSAoaHR0cHM6Ly9naXRodWIuY29tL3N0cmlwZS9yZWFjdC1zdHJpcGUtanMvaXNzdWVzLzI5NilcbiAgICAgICAgaWYgKGN0eC5zdHJpcGUpIHJldHVybiBjdHg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RyaXBlOiBzdHJpcGUsXG4gICAgICAgICAgZWxlbWVudHM6IHN0cmlwZS5lbGVtZW50cyhvcHRpb25zKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTsgLy8gRm9yIGFuIGFzeW5jIHN0cmlwZVByb21pc2UsIHN0b3JlIGl0IGluIGNvbnRleHQgb25jZSByZXNvbHZlZFxuXG5cbiAgICBpZiAocGFyc2VkLnRhZyA9PT0gJ2FzeW5jJyAmJiAhY3R4LnN0cmlwZSkge1xuICAgICAgcGFyc2VkLnN0cmlwZVByb21pc2UudGhlbihmdW5jdGlvbiAoc3RyaXBlKSB7XG4gICAgICAgIGlmIChzdHJpcGUgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgICAgLy8gT25seSB1cGRhdGUgRWxlbWVudHMgY29udGV4dCBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWRcbiAgICAgICAgICAvLyBhbmQgc3RyaXBlIGlzIG5vdCBudWxsLiBXZSBhbGxvdyBzdHJpcGUgdG8gYmUgbnVsbCB0byBtYWtlXG4gICAgICAgICAgLy8gaGFuZGxpbmcgU1NSIGVhc2llci5cbiAgICAgICAgICBzYWZlU2V0Q29udGV4dChzdHJpcGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC50YWcgPT09ICdzeW5jJyAmJiAhY3R4LnN0cmlwZSkge1xuICAgICAgLy8gT3IsIGhhbmRsZSBhIHN5bmMgc3RyaXBlIGluc3RhbmNlIGdvaW5nIGZyb20gbnVsbCAtPiBwb3B1bGF0ZWRcbiAgICAgIHNhZmVTZXRDb250ZXh0KHBhcnNlZC5zdHJpcGUpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbcGFyc2VkLCBjdHgsIG9wdGlvbnNdKTsgLy8gV2FybiBvbiBjaGFuZ2VzIHRvIHN0cmlwZSBwcm9wXG5cbiAgdmFyIHByZXZTdHJpcGUgPSB1c2VQcmV2aW91cyhyYXdTdHJpcGVQcm9wKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJldlN0cmlwZSAhPT0gbnVsbCAmJiBwcmV2U3RyaXBlICE9PSByYXdTdHJpcGVQcm9wKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEVsZW1lbnRzOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgYHN0cmlwZWAgcHJvcCBhZnRlciBzZXR0aW5nIGl0LicpO1xuICAgIH1cbiAgfSwgW3ByZXZTdHJpcGUsIHJhd1N0cmlwZVByb3BdKTsgLy8gQXBwbHkgdXBkYXRlcyB0byBlbGVtZW50cyB3aGVuIG9wdGlvbnMgcHJvcCBoYXMgcmVsZXZhbnQgY2hhbmdlc1xuXG4gIHZhciBwcmV2T3B0aW9ucyA9IHVzZVByZXZpb3VzKG9wdGlvbnMpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghY3R4LmVsZW1lbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZXMgPSBleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzKG9wdGlvbnMsIHByZXZPcHRpb25zLCBbJ2NsaWVudFNlY3JldCcsICdmb250cyddKTtcblxuICAgIGlmICh1cGRhdGVzKSB7XG4gICAgICBjdHguZWxlbWVudHMudXBkYXRlKHVwZGF0ZXMpO1xuICAgIH1cbiAgfSwgW29wdGlvbnMsIHByZXZPcHRpb25zLCBjdHguZWxlbWVudHNdKTsgLy8gQXR0YWNoIHJlYWN0LXN0cmlwZS1qcyB2ZXJzaW9uIHRvIHN0cmlwZS5qcyBpbnN0YW5jZVxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVnaXN0ZXJXaXRoU3RyaXBlSnMoY3R4LnN0cmlwZSk7XG4gIH0sIFtjdHguc3RyaXBlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbGVtZW50c0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY3R4XG4gIH0sIGNoaWxkcmVuKTtcbn07XG5FbGVtZW50cy5wcm9wVHlwZXMgPSB7XG4gIHN0cmlwZTogUHJvcFR5cGVzLmFueSxcbiAgb3B0aW9uczogUHJvcFR5cGVzLm9iamVjdFxufTtcbnZhciB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZSA9IGZ1bmN0aW9uIHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlKHVzZUNhc2VNZXNzYWdlKSB7XG4gIHZhciBjdHggPSBSZWFjdC51c2VDb250ZXh0KEVsZW1lbnRzQ29udGV4dCk7XG4gIHJldHVybiBwYXJzZUVsZW1lbnRzQ29udGV4dChjdHgsIHVzZUNhc2VNZXNzYWdlKTtcbn07XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCN1c2VlbGVtZW50cy1ob29rXG4gKi9cblxudmFyIHVzZUVsZW1lbnRzID0gZnVuY3Rpb24gdXNlRWxlbWVudHMoKSB7XG4gIHZhciBfdXNlRWxlbWVudHNDb250ZXh0V2kgPSB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZSgnY2FsbHMgdXNlRWxlbWVudHMoKScpLFxuICAgICAgZWxlbWVudHMgPSBfdXNlRWxlbWVudHNDb250ZXh0V2kuZWxlbWVudHM7XG5cbiAgcmV0dXJuIGVsZW1lbnRzO1xufTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLWNvbnN1bWVyXG4gKi9cblxudmFyIEVsZW1lbnRzQ29uc3VtZXIgPSBmdW5jdGlvbiBFbGVtZW50c0NvbnN1bWVyKF9yZWYyKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYyLmNoaWxkcmVuO1xuICB2YXIgY3R4ID0gdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UoJ21vdW50cyA8RWxlbWVudHNDb25zdW1lcj4nKTsgLy8gQXNzZXJ0IHRvIHNhdGlzZnkgdGhlIGJ1c3RlZCBSZWFjdC5GQyByZXR1cm4gdHlwZSAoaXQgc2hvdWxkIGJlIFJlYWN0Tm9kZSlcblxuICByZXR1cm4gY2hpbGRyZW4oY3R4KTtcbn07XG5FbGVtZW50c0NvbnN1bWVyLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn07XG5cbnZhciBfZXhjbHVkZWQkMSA9IFtcIm9uXCIsIFwic2Vzc2lvblwiXTtcbnZhciBDaGVja291dFNka0NvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkNoZWNrb3V0U2RrQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdDaGVja291dFNka0NvbnRleHQnO1xudmFyIHBhcnNlQ2hlY2tvdXRTZGtDb250ZXh0ID0gZnVuY3Rpb24gcGFyc2VDaGVja291dFNka0NvbnRleHQoY3R4LCB1c2VDYXNlKSB7XG4gIGlmICghY3R4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgQ2hlY2tvdXRQcm92aWRlciBjb250ZXh0OyBZb3UgbmVlZCB0byB3cmFwIHRoZSBwYXJ0IG9mIHlvdXIgYXBwIHRoYXQgXCIuY29uY2F0KHVzZUNhc2UsIFwiIGluIGFuIDxDaGVja291dFByb3ZpZGVyPiBwcm92aWRlci5cIikpO1xuICB9XG5cbiAgcmV0dXJuIGN0eDtcbn07XG52YXIgQ2hlY2tvdXRDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5DaGVja291dENvbnRleHQuZGlzcGxheU5hbWUgPSAnQ2hlY2tvdXRDb250ZXh0JztcbnZhciBleHRyYWN0Q2hlY2tvdXRDb250ZXh0VmFsdWUgPSBmdW5jdGlvbiBleHRyYWN0Q2hlY2tvdXRDb250ZXh0VmFsdWUoY2hlY2tvdXRTZGssIHNlc3Npb25TdGF0ZSkge1xuICBpZiAoIWNoZWNrb3V0U2RrKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjaGVja291dFNkay5vbjtcbiAgICAgIGNoZWNrb3V0U2RrLnNlc3Npb247XG4gICAgICB2YXIgYWN0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhjaGVja291dFNkaywgX2V4Y2x1ZGVkJDEpO1xuXG4gIGlmICghc2Vzc2lvblN0YXRlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY2hlY2tvdXRTZGsuc2Vzc2lvbigpLCBhY3Rpb25zKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHNlc3Npb25TdGF0ZSwgYWN0aW9ucyk7XG59O1xudmFyIElOVkFMSURfU1RSSVBFX0VSUk9SJDEgPSAnSW52YWxpZCBwcm9wIGBzdHJpcGVgIHN1cHBsaWVkIHRvIGBDaGVja291dFByb3ZpZGVyYC4gV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBgbG9hZFN0cmlwZWAgdXRpbGl0eSBmcm9tIGBAc3RyaXBlL3N0cmlwZS1qc2AuIFNlZSBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudHMtcHJvcHMtc3RyaXBlIGZvciBkZXRhaWxzLic7XG52YXIgQ2hlY2tvdXRQcm92aWRlciA9IGZ1bmN0aW9uIENoZWNrb3V0UHJvdmlkZXIoX3JlZikge1xuICB2YXIgcmF3U3RyaXBlUHJvcCA9IF9yZWYuc3RyaXBlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgdmFyIHBhcnNlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXJzZVN0cmlwZVByb3AocmF3U3RyaXBlUHJvcCwgSU5WQUxJRF9TVFJJUEVfRVJST1IkMSk7XG4gIH0sIFtyYXdTdHJpcGVQcm9wXSk7IC8vIFN0YXRlIHVzZWQgdG8gdHJpZ2dlciBhIHJlLXJlbmRlciB3aGVuIHNkay5zZXNzaW9uIGlzIHVwZGF0ZWRcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUobnVsbCksXG4gICAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICAgIHNlc3Npb24gPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0U2Vzc2lvbiA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTMgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmlwZTogcGFyc2VkLnRhZyA9PT0gJ3N5bmMnID8gcGFyc2VkLnN0cmlwZSA6IG51bGwsXG4gICAgICBjaGVja291dFNkazogbnVsbFxuICAgIH07XG4gIH0pLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlNCA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZTMsIDIpLFxuICAgICAgY3R4ID0gX1JlYWN0JHVzZVN0YXRlNFswXSxcbiAgICAgIHNldENvbnRleHQgPSBfUmVhY3QkdXNlU3RhdGU0WzFdO1xuXG4gIHZhciBzYWZlU2V0Q29udGV4dCA9IGZ1bmN0aW9uIHNhZmVTZXRDb250ZXh0KHN0cmlwZSwgY2hlY2tvdXRTZGspIHtcbiAgICBzZXRDb250ZXh0KGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIGlmIChjdHguc3RyaXBlICYmIGN0eC5jaGVja291dFNkaykge1xuICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJpcGU6IHN0cmlwZSxcbiAgICAgICAgY2hlY2tvdXRTZGs6IGNoZWNrb3V0U2RrXG4gICAgICB9O1xuICAgIH0pO1xuICB9OyAvLyBSZWYgdXNlZCB0byBhdm9pZCBjYWxsaW5nIGluaXRDaGVja291dCBtdWx0aXBsZSB0aW1lcyB3aGVuIG9wdGlvbnMgY2hhbmdlc1xuXG5cbiAgdmFyIGluaXRDaGVja291dENhbGxlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlzTW91bnRlZCA9IHRydWU7XG5cbiAgICBpZiAocGFyc2VkLnRhZyA9PT0gJ2FzeW5jJyAmJiAhY3R4LnN0cmlwZSkge1xuICAgICAgcGFyc2VkLnN0cmlwZVByb21pc2UudGhlbihmdW5jdGlvbiAoc3RyaXBlKSB7XG4gICAgICAgIGlmIChzdHJpcGUgJiYgaXNNb3VudGVkICYmICFpbml0Q2hlY2tvdXRDYWxsZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIGNvbnRleHQgaWYgdGhlIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkXG4gICAgICAgICAgLy8gYW5kIHN0cmlwZSBpcyBub3QgbnVsbC4gV2UgYWxsb3cgc3RyaXBlIHRvIGJlIG51bGwgdG8gbWFrZVxuICAgICAgICAgIC8vIGhhbmRsaW5nIFNTUiBlYXNpZXIuXG4gICAgICAgICAgaW5pdENoZWNrb3V0Q2FsbGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIHN0cmlwZS5pbml0Q2hlY2tvdXQob3B0aW9ucykudGhlbihmdW5jdGlvbiAoY2hlY2tvdXRTZGspIHtcbiAgICAgICAgICAgIGlmIChjaGVja291dFNkaykge1xuICAgICAgICAgICAgICBzYWZlU2V0Q29udGV4dChzdHJpcGUsIGNoZWNrb3V0U2RrKTtcbiAgICAgICAgICAgICAgY2hlY2tvdXRTZGsub24oJ2NoYW5nZScsIHNldFNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC50YWcgPT09ICdzeW5jJyAmJiBwYXJzZWQuc3RyaXBlICYmICFpbml0Q2hlY2tvdXRDYWxsZWRSZWYuY3VycmVudCkge1xuICAgICAgaW5pdENoZWNrb3V0Q2FsbGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgcGFyc2VkLnN0cmlwZS5pbml0Q2hlY2tvdXQob3B0aW9ucykudGhlbihmdW5jdGlvbiAoY2hlY2tvdXRTZGspIHtcbiAgICAgICAgaWYgKGNoZWNrb3V0U2RrKSB7XG4gICAgICAgICAgc2FmZVNldENvbnRleHQocGFyc2VkLnN0cmlwZSwgY2hlY2tvdXRTZGspO1xuICAgICAgICAgIGNoZWNrb3V0U2RrLm9uKCdjaGFuZ2UnLCBzZXRTZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtwYXJzZWQsIGN0eCwgb3B0aW9ucywgc2V0U2Vzc2lvbl0pOyAvLyBXYXJuIG9uIGNoYW5nZXMgdG8gc3RyaXBlIHByb3BcblxuICB2YXIgcHJldlN0cmlwZSA9IHVzZVByZXZpb3VzKHJhd1N0cmlwZVByb3ApO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcmV2U3RyaXBlICE9PSBudWxsICYmIHByZXZTdHJpcGUgIT09IHJhd1N0cmlwZVByb3ApIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gQ2hlY2tvdXRQcm92aWRlcjogWW91IGNhbm5vdCBjaGFuZ2UgdGhlIGBzdHJpcGVgIHByb3AgYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG4gIH0sIFtwcmV2U3RyaXBlLCByYXdTdHJpcGVQcm9wXSk7IC8vIEFwcGx5IHVwZGF0ZXMgdG8gZWxlbWVudHMgd2hlbiBvcHRpb25zIHByb3AgaGFzIHJlbGV2YW50IGNoYW5nZXNcblxuICB2YXIgcHJldk9wdGlvbnMgPSB1c2VQcmV2aW91cyhvcHRpb25zKTtcbiAgdmFyIHByZXZDaGVja291dFNkayA9IHVzZVByZXZpb3VzKGN0eC5jaGVja291dFNkayk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wcmV2T3B0aW9ucyRlbGVtZW50cywgX29wdGlvbnMkZWxlbWVudHNPcHRpLCBfcHJldk9wdGlvbnMkZWxlbWVudHMyLCBfb3B0aW9ucyRlbGVtZW50c09wdGkyO1xuXG4gICAgLy8gSWdub3JlIGNoYW5nZXMgd2hpbGUgY2hlY2tvdXQgc2RrIGlzIG5vdCBpbml0aWFsaXplZC5cbiAgICBpZiAoIWN0eC5jaGVja291dFNkaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBoYXNTZGtMb2FkZWQgPSBCb29sZWFuKCFwcmV2Q2hlY2tvdXRTZGsgJiYgY3R4LmNoZWNrb3V0U2RrKTsgLy8gSGFuZGxlIGFwcGVhcmFuY2UgY2hhbmdlc1xuXG4gICAgdmFyIHByZXZpb3VzQXBwZWFyYW5jZSA9IHByZXZPcHRpb25zID09PSBudWxsIHx8IHByZXZPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3ByZXZPcHRpb25zJGVsZW1lbnRzID0gcHJldk9wdGlvbnMuZWxlbWVudHNPcHRpb25zKSA9PT0gbnVsbCB8fCBfcHJldk9wdGlvbnMkZWxlbWVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcmV2T3B0aW9ucyRlbGVtZW50cy5hcHBlYXJhbmNlO1xuICAgIHZhciBjdXJyZW50QXBwZWFyYW5jZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9vcHRpb25zJGVsZW1lbnRzT3B0aSA9IG9wdGlvbnMuZWxlbWVudHNPcHRpb25zKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRlbGVtZW50c09wdGkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGVsZW1lbnRzT3B0aS5hcHBlYXJhbmNlO1xuICAgIHZhciBoYXNBcHBlYXJhbmNlQ2hhbmdlZCA9ICFpc0VxdWFsKGN1cnJlbnRBcHBlYXJhbmNlLCBwcmV2aW91c0FwcGVhcmFuY2UpO1xuXG4gICAgaWYgKGN1cnJlbnRBcHBlYXJhbmNlICYmIChoYXNBcHBlYXJhbmNlQ2hhbmdlZCB8fCBoYXNTZGtMb2FkZWQpKSB7XG4gICAgICBjdHguY2hlY2tvdXRTZGsuY2hhbmdlQXBwZWFyYW5jZShjdXJyZW50QXBwZWFyYW5jZSk7XG4gICAgfSAvLyBIYW5kbGUgZm9udHMgY2hhbmdlc1xuXG5cbiAgICB2YXIgcHJldmlvdXNGb250cyA9IHByZXZPcHRpb25zID09PSBudWxsIHx8IHByZXZPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3ByZXZPcHRpb25zJGVsZW1lbnRzMiA9IHByZXZPcHRpb25zLmVsZW1lbnRzT3B0aW9ucykgPT09IG51bGwgfHwgX3ByZXZPcHRpb25zJGVsZW1lbnRzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ByZXZPcHRpb25zJGVsZW1lbnRzMi5mb250cztcbiAgICB2YXIgY3VycmVudEZvbnRzID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX29wdGlvbnMkZWxlbWVudHNPcHRpMiA9IG9wdGlvbnMuZWxlbWVudHNPcHRpb25zKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRlbGVtZW50c09wdGkyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRlbGVtZW50c09wdGkyLmZvbnRzO1xuICAgIHZhciBoYXNGb250c0NoYW5nZWQgPSAhaXNFcXVhbChwcmV2aW91c0ZvbnRzLCBjdXJyZW50Rm9udHMpO1xuXG4gICAgaWYgKGN1cnJlbnRGb250cyAmJiAoaGFzRm9udHNDaGFuZ2VkIHx8IGhhc1Nka0xvYWRlZCkpIHtcbiAgICAgIGN0eC5jaGVja291dFNkay5sb2FkRm9udHMoY3VycmVudEZvbnRzKTtcbiAgICB9XG4gIH0sIFtvcHRpb25zLCBwcmV2T3B0aW9ucywgY3R4LmNoZWNrb3V0U2RrLCBwcmV2Q2hlY2tvdXRTZGtdKTsgLy8gQXR0YWNoIHJlYWN0LXN0cmlwZS1qcyB2ZXJzaW9uIHRvIHN0cmlwZS5qcyBpbnN0YW5jZVxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVnaXN0ZXJXaXRoU3RyaXBlSnMoY3R4LnN0cmlwZSk7XG4gIH0sIFtjdHguc3RyaXBlXSk7XG4gIHZhciBjaGVja291dENvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBleHRyYWN0Q2hlY2tvdXRDb250ZXh0VmFsdWUoY3R4LmNoZWNrb3V0U2RrLCBzZXNzaW9uKTtcbiAgfSwgW2N0eC5jaGVja291dFNkaywgc2Vzc2lvbl0pO1xuXG4gIGlmICghY3R4LmNoZWNrb3V0U2RrKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2tvdXRTZGtDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGN0eFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDaGVja291dENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY2hlY2tvdXRDb250ZXh0VmFsdWVcbiAgfSwgY2hpbGRyZW4pKTtcbn07XG5DaGVja291dFByb3ZpZGVyLnByb3BUeXBlcyA9IHtcbiAgc3RyaXBlOiBQcm9wVHlwZXMuYW55LFxuICBvcHRpb25zOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGZldGNoQ2xpZW50U2VjcmV0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGVsZW1lbnRzT3B0aW9uczogUHJvcFR5cGVzLm9iamVjdFxuICB9KS5pc1JlcXVpcmVkXG59O1xudmFyIHVzZUNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlID0gZnVuY3Rpb24gdXNlQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UodXNlQ2FzZVN0cmluZykge1xuICB2YXIgY3R4ID0gUmVhY3QudXNlQ29udGV4dChDaGVja291dFNka0NvbnRleHQpO1xuICByZXR1cm4gcGFyc2VDaGVja291dFNka0NvbnRleHQoY3R4LCB1c2VDYXNlU3RyaW5nKTtcbn07XG52YXIgdXNlRWxlbWVudHNPckNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlID0gZnVuY3Rpb24gdXNlRWxlbWVudHNPckNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlKHVzZUNhc2VTdHJpbmcpIHtcbiAgdmFyIGNoZWNrb3V0U2RrQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQ2hlY2tvdXRTZGtDb250ZXh0KTtcbiAgdmFyIGVsZW1lbnRzQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRWxlbWVudHNDb250ZXh0KTtcblxuICBpZiAoY2hlY2tvdXRTZGtDb250ZXh0ICYmIGVsZW1lbnRzQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3Qgd3JhcCB0aGUgcGFydCBvZiB5b3VyIGFwcCB0aGF0IFwiLmNvbmNhdCh1c2VDYXNlU3RyaW5nLCBcIiBpbiBib3RoIDxDaGVja291dFByb3ZpZGVyPiBhbmQgPEVsZW1lbnRzPiBwcm92aWRlcnMuXCIpKTtcbiAgfVxuXG4gIGlmIChjaGVja291dFNka0NvbnRleHQpIHtcbiAgICByZXR1cm4gcGFyc2VDaGVja291dFNka0NvbnRleHQoY2hlY2tvdXRTZGtDb250ZXh0LCB1c2VDYXNlU3RyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUVsZW1lbnRzQ29udGV4dChlbGVtZW50c0NvbnRleHQsIHVzZUNhc2VTdHJpbmcpO1xufTtcbnZhciB1c2VDaGVja291dCA9IGZ1bmN0aW9uIHVzZUNoZWNrb3V0KCkge1xuICAvLyBlbnN1cmUgaXQncyBpbiBDaGVja291dFByb3ZpZGVyXG4gIHVzZUNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlKCdjYWxscyB1c2VDaGVja291dCgpJyk7XG4gIHZhciBjdHggPSBSZWFjdC51c2VDb250ZXh0KENoZWNrb3V0Q29udGV4dCk7XG5cbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIENoZWNrb3V0IENvbnRleHQ7IFlvdSBuZWVkIHRvIHdyYXAgdGhlIHBhcnQgb2YgeW91ciBhcHAgdGhhdCBjYWxscyB1c2VDaGVja291dCgpIGluIGFuIDxDaGVja291dFByb3ZpZGVyPiBwcm92aWRlci4nKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xuXG52YXIgX2V4Y2x1ZGVkID0gW1wibW9kZVwiXTtcblxudmFyIGNhcGl0YWxpemVkID0gZnVuY3Rpb24gY2FwaXRhbGl6ZWQoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59O1xuXG52YXIgY3JlYXRlRWxlbWVudENvbXBvbmVudCA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRDb21wb25lbnQodHlwZSwgaXNTZXJ2ZXIpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gXCJcIi5jb25jYXQoY2FwaXRhbGl6ZWQodHlwZSksIFwiRWxlbWVudFwiKTtcblxuICB2YXIgQ2xpZW50RWxlbWVudCA9IGZ1bmN0aW9uIENsaWVudEVsZW1lbnQoX3JlZikge1xuICAgIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgICBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRvcHRpb25zLFxuICAgICAgICBvbkJsdXIgPSBfcmVmLm9uQmx1cixcbiAgICAgICAgb25Gb2N1cyA9IF9yZWYub25Gb2N1cyxcbiAgICAgICAgb25SZWFkeSA9IF9yZWYub25SZWFkeSxcbiAgICAgICAgb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlLFxuICAgICAgICBvbkVzY2FwZSA9IF9yZWYub25Fc2NhcGUsXG4gICAgICAgIG9uQ2xpY2sgPSBfcmVmLm9uQ2xpY2ssXG4gICAgICAgIG9uTG9hZEVycm9yID0gX3JlZi5vbkxvYWRFcnJvcixcbiAgICAgICAgb25Mb2FkZXJTdGFydCA9IF9yZWYub25Mb2FkZXJTdGFydCxcbiAgICAgICAgb25OZXR3b3Jrc0NoYW5nZSA9IF9yZWYub25OZXR3b3Jrc0NoYW5nZSxcbiAgICAgICAgb25Db25maXJtID0gX3JlZi5vbkNvbmZpcm0sXG4gICAgICAgIG9uQ2FuY2VsID0gX3JlZi5vbkNhbmNlbCxcbiAgICAgICAgb25TaGlwcGluZ0FkZHJlc3NDaGFuZ2UgPSBfcmVmLm9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlLFxuICAgICAgICBvblNoaXBwaW5nUmF0ZUNoYW5nZSA9IF9yZWYub25TaGlwcGluZ1JhdGVDaGFuZ2UsXG4gICAgICAgIG9uU2F2ZWRQYXltZW50TWV0aG9kUmVtb3ZlID0gX3JlZi5vblNhdmVkUGF5bWVudE1ldGhvZFJlbW92ZSxcbiAgICAgICAgb25TYXZlZFBheW1lbnRNZXRob2RVcGRhdGUgPSBfcmVmLm9uU2F2ZWRQYXltZW50TWV0aG9kVXBkYXRlO1xuICAgIHZhciBjdHggPSB1c2VFbGVtZW50c09yQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UoXCJtb3VudHMgPFwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCI+XCIpKTtcbiAgICB2YXIgZWxlbWVudHMgPSAnZWxlbWVudHMnIGluIGN0eCA/IGN0eC5lbGVtZW50cyA6IG51bGw7XG4gICAgdmFyIGNoZWNrb3V0U2RrID0gJ2NoZWNrb3V0U2RrJyBpbiBjdHggPyBjdHguY2hlY2tvdXRTZGsgOiBudWxsO1xuXG4gICAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICAgICAgZWxlbWVudCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICAgIHNldEVsZW1lbnQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gICAgdmFyIGVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgdmFyIGRvbU5vZGUgPSBSZWFjdC51c2VSZWYobnVsbCk7IC8vIEZvciBldmVyeSBldmVudCB3aGVyZSB0aGUgbWVyY2hhbnQgcHJvdmlkZXMgYSBjYWxsYmFjaywgY2FsbCBlbGVtZW50Lm9uXG4gICAgLy8gd2l0aCB0aGF0IGNhbGxiYWNrLiBJZiB0aGUgbWVyY2hhbnQgZXZlciBjaGFuZ2VzIHRoZSBjYWxsYmFjaywgcmVtb3Zlc1xuICAgIC8vIHRoZSBvbGQgY2FsbGJhY2sgd2l0aCBlbGVtZW50Lm9mZiBhbmQgdGhlbiBjYWxsIGVsZW1lbnQub24gd2l0aCB0aGUgbmV3IG9uZS5cblxuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdibHVyJywgb25CbHVyKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnZm9jdXMnLCBvbkZvY3VzKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnZXNjYXBlJywgb25Fc2NhcGUpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjbGljaycsIG9uQ2xpY2spO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdsb2FkZXJyb3InLCBvbkxvYWRFcnJvcik7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2xvYWRlcnN0YXJ0Jywgb25Mb2FkZXJTdGFydCk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ25ldHdvcmtzY2hhbmdlJywgb25OZXR3b3Jrc0NoYW5nZSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2NvbmZpcm0nLCBvbkNvbmZpcm0pO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjYW5jZWwnLCBvbkNhbmNlbCk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3NoaXBwaW5nYWRkcmVzc2NoYW5nZScsIG9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnc2hpcHBpbmdyYXRlY2hhbmdlJywgb25TaGlwcGluZ1JhdGVDaGFuZ2UpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdzYXZlZHBheW1lbnRtZXRob2RyZW1vdmUnLCBvblNhdmVkUGF5bWVudE1ldGhvZFJlbW92ZSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3NhdmVkcGF5bWVudG1ldGhvZHVwZGF0ZScsIG9uU2F2ZWRQYXltZW50TWV0aG9kVXBkYXRlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIHZhciByZWFkeUNhbGxiYWNrO1xuXG4gICAgaWYgKG9uUmVhZHkpIHtcbiAgICAgIGlmICh0eXBlID09PSAnZXhwcmVzc0NoZWNrb3V0Jykge1xuICAgICAgICAvLyBQYXNzZXMgdGhyb3VnaCB0aGUgZXZlbnQsIHdoaWNoIGluY2x1ZGVzIHZpc2libGUgUE0gdHlwZXNcbiAgICAgICAgcmVhZHlDYWxsYmFjayA9IG9uUmVhZHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb3RoZXIgRWxlbWVudHMsIHBhc3MgdGhyb3VnaCB0aGUgRWxlbWVudCBpdHNlbGYuXG4gICAgICAgIHJlYWR5Q2FsbGJhY2sgPSBmdW5jdGlvbiByZWFkeUNhbGxiYWNrKCkge1xuICAgICAgICAgIG9uUmVhZHkoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3JlYWR5JywgcmVhZHlDYWxsYmFjayk7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbGVtZW50UmVmLmN1cnJlbnQgPT09IG51bGwgJiYgZG9tTm9kZS5jdXJyZW50ICE9PSBudWxsICYmIChlbGVtZW50cyB8fCBjaGVja291dFNkaykpIHtcbiAgICAgICAgdmFyIG5ld0VsZW1lbnQgPSBudWxsO1xuXG4gICAgICAgIGlmIChjaGVja291dFNkaykge1xuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncGF5bWVudCc6XG4gICAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBjaGVja291dFNkay5jcmVhdGVQYXltZW50RWxlbWVudChvcHRpb25zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgICAgICAgICBpZiAoJ21vZGUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdE9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3B0aW9ucywgX2V4Y2x1ZGVkKTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAnc2hpcHBpbmcnKSB7XG4gICAgICAgICAgICAgICAgICBuZXdFbGVtZW50ID0gY2hlY2tvdXRTZGsuY3JlYXRlU2hpcHBpbmdBZGRyZXNzRWxlbWVudChyZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnYmlsbGluZycpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBjaGVja291dFNkay5jcmVhdGVCaWxsaW5nQWRkcmVzc0VsZW1lbnQocmVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wdGlvbnMubW9kZS4gbW9kZSBtdXN0IGJlICdiaWxsaW5nJyBvciAnc2hpcHBpbmcnLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3Qgc3VwcGx5IG9wdGlvbnMubW9kZS4gbW9kZSBtdXN0IGJlICdiaWxsaW5nJyBvciAnc2hpcHBpbmcnLlwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdleHByZXNzQ2hlY2tvdXQnOlxuICAgICAgICAgICAgICBuZXdFbGVtZW50ID0gY2hlY2tvdXRTZGsuY3JlYXRlRXhwcmVzc0NoZWNrb3V0RWxlbWVudChvcHRpb25zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2N1cnJlbmN5U2VsZWN0b3InOlxuICAgICAgICAgICAgICBuZXdFbGVtZW50ID0gY2hlY2tvdXRTZGsuY3JlYXRlQ3VycmVuY3lTZWxlY3RvckVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3RheElkJzpcbiAgICAgICAgICAgICAgbmV3RWxlbWVudCA9IGNoZWNrb3V0U2RrLmNyZWF0ZVRheElkRWxlbWVudChvcHRpb25zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRWxlbWVudCB0eXBlIFwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCIuIFlvdSBtdXN0IHVzZSBlaXRoZXIgdGhlIDxQYXltZW50RWxlbWVudCAvPiwgPEFkZHJlc3NFbGVtZW50IG9wdGlvbnM9e3ttb2RlOiAnc2hpcHBpbmcnfX0gLz4sIDxBZGRyZXNzRWxlbWVudCBvcHRpb25zPXt7bW9kZTogJ2JpbGxpbmcnfX0gLz4sIG9yIDxFeHByZXNzQ2hlY2tvdXRFbGVtZW50IC8+LlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgbmV3RWxlbWVudCA9IGVsZW1lbnRzLmNyZWF0ZSh0eXBlLCBvcHRpb25zKTtcbiAgICAgICAgfSAvLyBTdG9yZSBlbGVtZW50IGluIGEgcmVmIHRvIGVuc3VyZSBpdCdzIF9pbW1lZGlhdGVseV8gYXZhaWxhYmxlIGluIGNsZWFudXAgaG9va3MgaW4gU3RyaWN0TW9kZVxuXG5cbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gbmV3RWxlbWVudDsgLy8gU3RvcmUgZWxlbWVudCBpbiBzdGF0ZSB0byBmYWNpbGl0YXRlIGV2ZW50IGxpc3RlbmVyIGF0dGFjaG1lbnRcblxuICAgICAgICBzZXRFbGVtZW50KG5ld0VsZW1lbnQpO1xuXG4gICAgICAgIGlmIChuZXdFbGVtZW50KSB7XG4gICAgICAgICAgbmV3RWxlbWVudC5tb3VudChkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2VsZW1lbnRzLCBjaGVja291dFNkaywgb3B0aW9uc10pO1xuICAgIHZhciBwcmV2T3B0aW9ucyA9IHVzZVByZXZpb3VzKG9wdGlvbnMpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVzID0gZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyhvcHRpb25zLCBwcmV2T3B0aW9ucywgWydwYXltZW50UmVxdWVzdCddKTtcblxuICAgICAgaWYgKHVwZGF0ZXMgJiYgJ3VwZGF0ZScgaW4gZWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudC51cGRhdGUodXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSwgW29wdGlvbnMsIHByZXZPcHRpb25zXSk7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChlbGVtZW50UmVmLmN1cnJlbnQgJiYgdHlwZW9mIGVsZW1lbnRSZWYuY3VycmVudC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudC5kZXN0cm95KCk7XG4gICAgICAgICAgICBlbGVtZW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gRG8gbm90aGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgcmVmOiBkb21Ob2RlXG4gICAgfSk7XG4gIH07IC8vIE9ubHkgcmVuZGVyIHRoZSBFbGVtZW50IHdyYXBwZXIgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG5cblxuICB2YXIgU2VydmVyRWxlbWVudCA9IGZ1bmN0aW9uIFNlcnZlckVsZW1lbnQocHJvcHMpIHtcbiAgICB1c2VFbGVtZW50c09yQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UoXCJtb3VudHMgPFwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCI+XCIpKTtcbiAgICB2YXIgaWQgPSBwcm9wcy5pZCxcbiAgICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBpZDogaWQsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBFbGVtZW50ID0gaXNTZXJ2ZXIgPyBTZXJ2ZXJFbGVtZW50IDogQ2xpZW50RWxlbWVudDtcbiAgRWxlbWVudC5wcm9wVHlwZXMgPSB7XG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUmVhZHk6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRXNjYXBlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxvYWRFcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Mb2FkZXJTdGFydDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25OZXR3b3Jrc0NoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Db25maXJtOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNhbmNlbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TaGlwcGluZ0FkZHJlc3NDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uU2hpcHBpbmdSYXRlQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblNhdmVkUGF5bWVudE1ldGhvZFJlbW92ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TYXZlZFBheW1lbnRNZXRob2RVcGRhdGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3RcbiAgfTtcbiAgRWxlbWVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICBFbGVtZW50Ll9fZWxlbWVudFR5cGUgPSB0eXBlO1xuICByZXR1cm4gRWxlbWVudDtcbn07XG5cbnZhciBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuXG52YXIgRW1iZWRkZWRDaGVja291dENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0VtYmVkZGVkQ2hlY2tvdXRQcm92aWRlckNvbnRleHQnO1xudmFyIHVzZUVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0ID0gZnVuY3Rpb24gdXNlRW1iZWRkZWRDaGVja291dENvbnRleHQoKSB7XG4gIHZhciBjdHggPSBSZWFjdC51c2VDb250ZXh0KEVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0KTtcblxuICBpZiAoIWN0eCkge1xuICAgIHRocm93IG5ldyBFcnJvcignPEVtYmVkZGVkQ2hlY2tvdXQ+IG11c3QgYmUgdXNlZCB3aXRoaW4gPEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcj4nKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xudmFyIElOVkFMSURfU1RSSVBFX0VSUk9SID0gJ0ludmFsaWQgcHJvcCBgc3RyaXBlYCBzdXBwbGllZCB0byBgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyYC4gV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBgbG9hZFN0cmlwZWAgdXRpbGl0eSBmcm9tIGBAc3RyaXBlL3N0cmlwZS1qc2AuIFNlZSBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudHMtcHJvcHMtc3RyaXBlIGZvciBkZXRhaWxzLic7XG52YXIgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyID0gZnVuY3Rpb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyKF9yZWYpIHtcbiAgdmFyIHJhd1N0cmlwZVByb3AgPSBfcmVmLnN0cmlwZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHZhciBwYXJzZWQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyc2VTdHJpcGVQcm9wKHJhd1N0cmlwZVByb3AsIElOVkFMSURfU1RSSVBFX0VSUk9SKTtcbiAgfSwgW3Jhd1N0cmlwZVByb3BdKTtcbiAgdmFyIGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgbG9hZGVkU3RyaXBlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgZW1iZWRkZWRDaGVja291dDogbnVsbFxuICB9KSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgICAgY3R4ID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldENvbnRleHQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgLy8gRG9uJ3Qgc3VwcG9ydCBhbnkgY3R4IHVwZGF0ZXMgb25jZSBlbWJlZGRlZENoZWNrb3V0IG9yIHN0cmlwZSBpcyBzZXQuXG4gICAgaWYgKGxvYWRlZFN0cmlwZS5jdXJyZW50IHx8IGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2V0U3RyaXBlQW5kSW5pdEVtYmVkZGVkQ2hlY2tvdXQgPSBmdW5jdGlvbiBzZXRTdHJpcGVBbmRJbml0RW1iZWRkZWRDaGVja291dChzdHJpcGUpIHtcbiAgICAgIGlmIChsb2FkZWRTdHJpcGUuY3VycmVudCB8fCBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50KSByZXR1cm47XG4gICAgICBsb2FkZWRTdHJpcGUuY3VycmVudCA9IHN0cmlwZTtcbiAgICAgIGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQgPSBsb2FkZWRTdHJpcGUuY3VycmVudC5pbml0RW1iZWRkZWRDaGVja291dChvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChlbWJlZGRlZENoZWNrb3V0KSB7XG4gICAgICAgIHNldENvbnRleHQoe1xuICAgICAgICAgIGVtYmVkZGVkQ2hlY2tvdXQ6IGVtYmVkZGVkQ2hlY2tvdXRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9OyAvLyBGb3IgYW4gYXN5bmMgc3RyaXBlUHJvbWlzZSwgc3RvcmUgaXQgb25jZSByZXNvbHZlZFxuXG5cbiAgICBpZiAocGFyc2VkLnRhZyA9PT0gJ2FzeW5jJyAmJiAhbG9hZGVkU3RyaXBlLmN1cnJlbnQgJiYgKG9wdGlvbnMuY2xpZW50U2VjcmV0IHx8IG9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXQpKSB7XG4gICAgICBwYXJzZWQuc3RyaXBlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzdHJpcGUpIHtcbiAgICAgICAgaWYgKHN0cmlwZSkge1xuICAgICAgICAgIHNldFN0cmlwZUFuZEluaXRFbWJlZGRlZENoZWNrb3V0KHN0cmlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnRhZyA9PT0gJ3N5bmMnICYmICFsb2FkZWRTdHJpcGUuY3VycmVudCAmJiAob3B0aW9ucy5jbGllbnRTZWNyZXQgfHwgb3B0aW9ucy5mZXRjaENsaWVudFNlY3JldCkpIHtcbiAgICAgIC8vIE9yLCBoYW5kbGUgYSBzeW5jIHN0cmlwZSBpbnN0YW5jZSBnb2luZyBmcm9tIG51bGwgLT4gcG9wdWxhdGVkXG4gICAgICBzZXRTdHJpcGVBbmRJbml0RW1iZWRkZWRDaGVja291dChwYXJzZWQuc3RyaXBlKTtcbiAgICB9XG4gIH0sIFtwYXJzZWQsIG9wdGlvbnMsIGN0eCwgbG9hZGVkU3RyaXBlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgLy8gY2xlYW51cCBvbiB1bm1vdW50XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIElmIGVtYmVkZGVkIGNoZWNrb3V0IGlzIGZ1bGx5IGluaXRpYWxpemVkLCBkZXN0cm95IGl0LlxuICAgICAgaWYgKGN0eC5lbWJlZGRlZENoZWNrb3V0KSB7XG4gICAgICAgIGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBjdHguZW1iZWRkZWRDaGVja291dC5kZXN0cm95KCk7XG4gICAgICB9IGVsc2UgaWYgKGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gSWYgZW1iZWRkZWQgY2hlY2tvdXQgaXMgc3RpbGwgaW5pdGlhbGl6aW5nLCBkZXN0cm95IGl0IG9uY2VcbiAgICAgICAgLy8gaXQncyBkb25lLiBUaGlzIGNvdWxkIGJlIGNhdXNlZCBieSB1bm1vdW50aW5nIHZlcnkgcXVpY2tseVxuICAgICAgICAvLyBhZnRlciBtb3VudGluZy5cbiAgICAgICAgZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgICAgIGlmIChjdHguZW1iZWRkZWRDaGVja291dCkge1xuICAgICAgICAgICAgY3R4LmVtYmVkZGVkQ2hlY2tvdXQuZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2N0eC5lbWJlZGRlZENoZWNrb3V0XSk7IC8vIEF0dGFjaCByZWFjdC1zdHJpcGUtanMgdmVyc2lvbiB0byBzdHJpcGUuanMgaW5zdGFuY2VcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdGVyV2l0aFN0cmlwZUpzKGxvYWRlZFN0cmlwZSk7XG4gIH0sIFtsb2FkZWRTdHJpcGVdKTsgLy8gV2FybiBvbiBjaGFuZ2VzIHRvIHN0cmlwZSBwcm9wLlxuICAvLyBUaGUgc3RyaXBlIHByb3AgdmFsdWUgY2FuIG9ubHkgZ28gZnJvbSBudWxsIHRvIG5vbi1udWxsIG9uY2UgYW5kXG4gIC8vIGNhbid0IGJlIGNoYW5nZWQgYWZ0ZXIgdGhhdC5cblxuICB2YXIgcHJldlN0cmlwZSA9IHVzZVByZXZpb3VzKHJhd1N0cmlwZVByb3ApO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcmV2U3RyaXBlICE9PSBudWxsICYmIHByZXZTdHJpcGUgIT09IHJhd1N0cmlwZVByb3ApIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgYHN0cmlwZWAgcHJvcCBhZnRlciBzZXR0aW5nIGl0LicpO1xuICAgIH1cbiAgfSwgW3ByZXZTdHJpcGUsIHJhd1N0cmlwZVByb3BdKTsgLy8gV2FybiBvbiBjaGFuZ2VzIHRvIG9wdGlvbnMuXG5cbiAgdmFyIHByZXZPcHRpb25zID0gdXNlUHJldmlvdXMob3B0aW9ucyk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZPcHRpb25zID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcjogWW91IGNhbm5vdCB1bnNldCBvcHRpb25zIGFmdGVyIHNldHRpbmcgdGhlbS4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jbGllbnRTZWNyZXQgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmZldGNoQ2xpZW50U2VjcmV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBwcm9wcyBwYXNzZWQgdG8gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgbXVzdCBwcm92aWRlIG9uZSBvZiBlaXRoZXIgYG9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXRgIG9yIGBvcHRpb25zLmNsaWVudFNlY3JldGAuJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZPcHRpb25zLmNsaWVudFNlY3JldCAhPSBudWxsICYmIG9wdGlvbnMuY2xpZW50U2VjcmV0ICE9PSBwcmV2T3B0aW9ucy5jbGllbnRTZWNyZXQpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgY2xpZW50IHNlY3JldCBhZnRlciBzZXR0aW5nIGl0LiBVbm1vdW50IGFuZCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZPcHRpb25zLmZldGNoQ2xpZW50U2VjcmV0ICE9IG51bGwgJiYgb3B0aW9ucy5mZXRjaENsaWVudFNlY3JldCAhPT0gcHJldk9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXQpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSBmZXRjaENsaWVudFNlY3JldCBhZnRlciBzZXR0aW5nIGl0LiBVbm1vdW50IGFuZCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZPcHRpb25zLm9uQ29tcGxldGUgIT0gbnVsbCAmJiBvcHRpb25zLm9uQ29tcGxldGUgIT09IHByZXZPcHRpb25zLm9uQ29tcGxldGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgb25Db21wbGV0ZSBvcHRpb24gYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJldk9wdGlvbnMub25TaGlwcGluZ0RldGFpbHNDaGFuZ2UgIT0gbnVsbCAmJiBvcHRpb25zLm9uU2hpcHBpbmdEZXRhaWxzQ2hhbmdlICE9PSBwcmV2T3B0aW9ucy5vblNoaXBwaW5nRGV0YWlsc0NoYW5nZSkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBvblNoaXBwaW5nRGV0YWlsc0NoYW5nZSBvcHRpb24gYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJldk9wdGlvbnMub25MaW5lSXRlbXNDaGFuZ2UgIT0gbnVsbCAmJiBvcHRpb25zLm9uTGluZUl0ZW1zQ2hhbmdlICE9PSBwcmV2T3B0aW9ucy5vbkxpbmVJdGVtc0NoYW5nZSkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBvbkxpbmVJdGVtc0NoYW5nZSBvcHRpb24gYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG4gIH0sIFtwcmV2T3B0aW9ucywgb3B0aW9uc10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW1iZWRkZWRDaGVja291dENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY3R4XG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbnZhciBFbWJlZGRlZENoZWNrb3V0Q2xpZW50RWxlbWVudCA9IGZ1bmN0aW9uIEVtYmVkZGVkQ2hlY2tvdXRDbGllbnRFbGVtZW50KF9yZWYpIHtcbiAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lO1xuXG4gIHZhciBfdXNlRW1iZWRkZWRDaGVja291dEMgPSB1c2VFbWJlZGRlZENoZWNrb3V0Q29udGV4dCgpLFxuICAgICAgZW1iZWRkZWRDaGVja291dCA9IF91c2VFbWJlZGRlZENoZWNrb3V0Qy5lbWJlZGRlZENoZWNrb3V0O1xuXG4gIHZhciBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICB2YXIgZG9tTm9kZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzTW91bnRlZC5jdXJyZW50ICYmIGVtYmVkZGVkQ2hlY2tvdXQgJiYgZG9tTm9kZS5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBlbWJlZGRlZENoZWNrb3V0Lm1vdW50KGRvbU5vZGUuY3VycmVudCk7XG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgfSAvLyBDbGVhbiB1cCBvbiB1bm1vdW50XG5cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQgJiYgZW1iZWRkZWRDaGVja291dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVtYmVkZGVkQ2hlY2tvdXQudW5tb3VudCgpO1xuICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsvLyBEbyBub3RoaW5nLlxuICAgICAgICAgIC8vIFBhcmVudCBlZmZlY3RzIGFyZSBkZXN0cm95ZWQgYmVmb3JlIGNoaWxkIGVmZmVjdHMsIHNvXG4gICAgICAgICAgLy8gaW4gY2FzZXMgd2hlcmUgYm90aCB0aGUgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyIGFuZFxuICAgICAgICAgIC8vIHRoZSBFbWJlZGRlZENoZWNrb3V0IGNvbXBvbmVudCBhcmUgcmVtb3ZlZCBhdCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHRpbWUsIHRoZSBlbWJlZGRlZENoZWNrb3V0IGluc3RhbmNlIHdpbGwgYmUgZGVzdHJveWVkLFxuICAgICAgICAgIC8vIHdoaWNoIGNhdXNlcyBhbiBlcnJvciB3aGVuIGNhbGxpbmcgdW5tb3VudC5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbWJlZGRlZENoZWNrb3V0XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBkb21Ob2RlLFxuICAgIGlkOiBpZCxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9KTtcbn07IC8vIE9ubHkgcmVuZGVyIHRoZSB3cmFwcGVyIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuXG5cbnZhciBFbWJlZGRlZENoZWNrb3V0U2VydmVyRWxlbWVudCA9IGZ1bmN0aW9uIEVtYmVkZGVkQ2hlY2tvdXRTZXJ2ZXJFbGVtZW50KF9yZWYyKSB7XG4gIHZhciBpZCA9IF9yZWYyLmlkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lO1xuICAvLyBWYWxpZGF0ZSB0aGF0IHdlIGFyZSBpbiB0aGUgcmlnaHQgY29udGV4dCBieSBjYWxsaW5nIHVzZUVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0LlxuICB1c2VFbWJlZGRlZENoZWNrb3V0Q29udGV4dCgpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGlkOiBpZCxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9KTtcbn07XG5cbnZhciBFbWJlZGRlZENoZWNrb3V0ID0gaXNTZXJ2ZXIgPyBFbWJlZGRlZENoZWNrb3V0U2VydmVyRWxlbWVudCA6IEVtYmVkZGVkQ2hlY2tvdXRDbGllbnRFbGVtZW50O1xuXG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCN1c2VzdHJpcGUtaG9va1xuICovXG5cbnZhciB1c2VTdHJpcGUgPSBmdW5jdGlvbiB1c2VTdHJpcGUoKSB7XG4gIHZhciBfdXNlRWxlbWVudHNPckNoZWNrb3UgPSB1c2VFbGVtZW50c09yQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UoJ2NhbGxzIHVzZVN0cmlwZSgpJyksXG4gICAgICBzdHJpcGUgPSBfdXNlRWxlbWVudHNPckNoZWNrb3Uuc3RyaXBlO1xuXG4gIHJldHVybiBzdHJpcGU7XG59O1xuXG4vKipcbiAqIFJlcXVpcmVzIGJldGEgYWNjZXNzOlxuICogQ29udGFjdCBbU3RyaXBlIHN1cHBvcnRdKGh0dHBzOi8vc3VwcG9ydC5zdHJpcGUuY29tLykgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBBdUJhbmtBY2NvdW50RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2F1QmFua0FjY291bnQnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQ2FyZEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJkJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIENhcmROdW1iZXJFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FyZE51bWJlcicsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBDYXJkRXhwaXJ5RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2NhcmRFeHBpcnknLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQ2FyZEN2Y0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJkQ3ZjJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEZweEJhbmtFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnZnB4QmFuaycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBJYmFuRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2liYW4nLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgSWRlYWxCYW5rRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2lkZWFsQmFuaycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBQMjRCYW5rRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3AyNEJhbmsnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgRXBzQmFua0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdlcHNCYW5rJywgaXNTZXJ2ZXIpO1xudmFyIFBheW1lbnRFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgncGF5bWVudCcsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBFeHByZXNzQ2hlY2tvdXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnZXhwcmVzc0NoZWNrb3V0JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBSZXF1aXJlcyBiZXRhIGFjY2VzczpcbiAqIENvbnRhY3QgW1N0cmlwZSBzdXBwb3J0XShodHRwczovL3N1cHBvcnQuc3RyaXBlLmNvbS8pIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5cbnZhciBDdXJyZW5jeVNlbGVjdG9yRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2N1cnJlbmN5U2VsZWN0b3InLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgUGF5bWVudFJlcXVlc3RCdXR0b25FbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgncGF5bWVudFJlcXVlc3RCdXR0b24nLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgTGlua0F1dGhlbnRpY2F0aW9uRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2xpbmtBdXRoZW50aWNhdGlvbicsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBBZGRyZXNzRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2FkZHJlc3MnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBVc2UgYEFkZHJlc3NFbGVtZW50YCBpbnN0ZWFkLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgU2hpcHBpbmdBZGRyZXNzRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3NoaXBwaW5nQWRkcmVzcycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBQYXltZW50TWV0aG9kTWVzc2FnaW5nRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3BheW1lbnRNZXRob2RNZXNzYWdpbmcnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQWZmaXJtTWVzc2FnZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdhZmZpcm1NZXNzYWdlJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEFmdGVycGF5Q2xlYXJwYXlNZXNzYWdlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2FmdGVycGF5Q2xlYXJwYXlNZXNzYWdlJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBSZXF1aXJlcyBiZXRhIGFjY2VzczpcbiAqIENvbnRhY3QgW1N0cmlwZSBzdXBwb3J0XShodHRwczovL3N1cHBvcnQuc3RyaXBlLmNvbS8pIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5cbnZhciBUYXhJZEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCd0YXhJZCcsIGlzU2VydmVyKTtcblxuZXhwb3J0IHsgQWRkcmVzc0VsZW1lbnQsIEFmZmlybU1lc3NhZ2VFbGVtZW50LCBBZnRlcnBheUNsZWFycGF5TWVzc2FnZUVsZW1lbnQsIEF1QmFua0FjY291bnRFbGVtZW50LCBDYXJkQ3ZjRWxlbWVudCwgQ2FyZEVsZW1lbnQsIENhcmRFeHBpcnlFbGVtZW50LCBDYXJkTnVtYmVyRWxlbWVudCwgQ2hlY2tvdXRQcm92aWRlciwgQ3VycmVuY3lTZWxlY3RvckVsZW1lbnQsIEVsZW1lbnRzLCBFbGVtZW50c0NvbnN1bWVyLCBFbWJlZGRlZENoZWNrb3V0LCBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIsIEVwc0JhbmtFbGVtZW50LCBFeHByZXNzQ2hlY2tvdXRFbGVtZW50LCBGcHhCYW5rRWxlbWVudCwgSWJhbkVsZW1lbnQsIElkZWFsQmFua0VsZW1lbnQsIExpbmtBdXRoZW50aWNhdGlvbkVsZW1lbnQsIFAyNEJhbmtFbGVtZW50LCBQYXltZW50RWxlbWVudCwgUGF5bWVudE1ldGhvZE1lc3NhZ2luZ0VsZW1lbnQsIFBheW1lbnRSZXF1ZXN0QnV0dG9uRWxlbWVudCwgU2hpcHBpbmdBZGRyZXNzRWxlbWVudCwgVGF4SWRFbGVtZW50LCB1c2VDaGVja291dCwgdXNlRWxlbWVudHMsIHVzZVN0cmlwZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs\n");

/***/ })

};
;